var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#SMLMData.SMLMData","page":"API Reference","title":"SMLMData.SMLMData","text":"SMLMData\n\nA Julia package for working with Single Molecule Localization Microscopy (SMLM) data.\n\nFeatures\n\nType system for emitters, cameras, and localization data\nPhysical coordinate handling (microns) with camera pixel mappings\nFiltering and ROI selection tools\nSMITE format compatibility\nMemory-efficient data structures\n\nBasic Usage\n\nusing SMLMData\n\n# Create a camera\ncam = IdealCamera(1:512, 1:512, 0.1)  # 512x512 camera with 0.1 micron pixels\n\n# Create some emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n]\n\n# Create SMLD object\nsmld = BasicSMLD(emitters, cam, 1, 1, Dict{String,Any}())\n\n# Filter operations\nroi = filter_roi(smld, 0.0:2.0, 1.0:3.0)\nbright = @filter(smld, photons > 1000)\n\nAPI Overview\n\nFor a comprehensive overview of the API, use the help mode on api:\n\n?api\n\nOr access the complete API documentation programmatically:\n\ndocs = SMLMData.api()\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMData.AbstractCamera","page":"API Reference","title":"SMLMData.AbstractCamera","text":"AbstractCamera\n\nAbstract base type for all camera implementations in single molecule localization microscopy (SMLM).\n\nInterface Requirements\n\nAny concrete subtype of AbstractCamera must provide:\n\nField Requirements:\npixel_edges_x::Vector{<:Real}: Vector of pixel edge positions in x direction\npixel_edges_y::Vector{<:Real}: Vector of pixel edge positions in y direction\nUnits:\nAll edge positions must be in physical units (microns)\nOrigin (0,0) corresponds to the top-left corner of the camera\nFor a camera with N×M pixels, there will be N+1 x-edges and M+1 y-edges\nCoordinate Convention:\nPixel (1,1) is centered at (pixelsizex/2, pixelsizey/2) microns\nEdge positions define the boundaries of pixels in physical space\nFirst edge position corresponds to the left/top edge of the first pixel\nLast edge position corresponds to the right/bottom edge of the last pixel\n\nNotes\n\nEdge positions must be monotonically increasing\nThe number of edges must be one more than the number of pixels in each dimension\nWhile pixels are typically uniform in size, this is not a requirement of the interface\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.AbstractEmitter","page":"API Reference","title":"SMLMData.AbstractEmitter","text":"AbstractEmitter\n\nAbstract supertype for all emitter types in single molecule localization microscopy (SMLM). All spatial coordinates are specified in physical units (microns).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.BasicSMLD","page":"API Reference","title":"SMLMData.BasicSMLD","text":"BasicSMLD{T,E<:AbstractEmitter} <: SMLD\n\nBasic container for single molecule localization data.\n\nFields\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in the acquisition\nmetadata::Dict{String,Any}: Additional dataset information\n\nType Parameters\n\nT: Numeric type for coordinates (typically Float64)\nE: Concrete emitter type\n\nExample\n\n# Create camera\ncam = IdealCamera(1:512, 1:512, 0.1)\n\n# Create some emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 1.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0; frame=1),\n    Emitter2DFit{Float64}(5.0, 5.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0; frame=2)\n]\n\n# Create metadata\nmetadata = Dict{String,Any}(\n    \"exposure_time\" => 0.1,\n    \"timestamp\" => now(),\n    \"sample\" => \"Test Sample\"\n)\n\n# Create SMLD object\ndata = BasicSMLD(emitters, cam, 2, 1, metadata)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.BasicSMLD-Union{Tuple{E}, Tuple{Vector{E}, AbstractCamera, Int64, Int64}, Tuple{Vector{E}, AbstractCamera, Int64, Int64, Dict{String, Any}}} where E<:AbstractEmitter","page":"API Reference","title":"SMLMData.BasicSMLD","text":"BasicSMLD(emitters::Vector{E}, camera::AbstractCamera,\n          n_frames::Int, n_datasets::Int,\n          metadata::Dict{String,Any}=Dict{String,Any}()) where E<:AbstractEmitter\n\nConstruct a BasicSMLD from a vector of emitters and required metadata.\n\nArguments\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in acquisition\nmetadata::Dict{String,Any}=Dict{String,Any}(): Optional additional information\n\nThe numeric type T is inferred from the camera's pixeledgesx type.\n\nExample\n\n# Create with minimal metadata\ndata = BasicSMLD(emitters, camera, 10, 1)\n\n# Create with additional metadata\ndata = BasicSMLD(emitters, camera, 10, 1, Dict(\n    \"exposure_time\" => 0.1,\n    \"timestamp\" => now()\n))\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.Emitter2D","page":"API Reference","title":"SMLMData.Emitter2D","text":"Emitter2D{T} <: AbstractEmitter\n\nRepresents a 2D emitter for SMLM simulations with position and brightness.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nphotons::T: number of photons emitted by the fluorophore\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter2DFit","page":"API Reference","title":"SMLMData.Emitter2DFit","text":"Emitter2DFit{T} <: AbstractEmitter\n\nRepresents fitted 2D localization results with uncertainties and temporal/tracking information.\n\nFields\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background in photons/pixel\nframe::Int: frame number in acquisition sequence\ndataset::Int: identifier for specific acquisition/dataset\ntrack_id::Int: identifier for linking localizations across frames (0 = unlinked)\nid::Int: unique identifier within dataset\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter2DFit-Union{Tuple{T}, NTuple{8, T}} where T","page":"API Reference","title":"SMLMData.Emitter2DFit","text":"Emitter2DFit{T}(x, y, photons, bg, σ_x, σ_y, σ_photons, σ_bg;\n                frame=0, dataset=1, track_id=0, id=0) where T\n\nConvenience constructor for 2D localization fit results with optional identification parameters.\n\nArguments\n\nRequired\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background level\n\nOptional Keywords\n\nframe::Int=1: frame number in acquisition sequence\ndataset::Int=1: identifier for specific acquisition/dataset\ntrack_id::Int=0: identifier for linking localizations across frames\nid::Int=0: unique identifier within dataset\n\nExample\n\n# Create emitter with just required parameters\nemitter = Emitter2DFit{Float64}(\n    1.0, 2.0,        # x, y\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01,      # σ_x, σ_y\n    50.0, 2.0        # σ_photons, σ_bg\n)\n\n# Create emitter with specific frame and dataset\nemitter = Emitter2DFit{Float64}(\n    1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0;\n    frame=5, dataset=2\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.Emitter3D","page":"API Reference","title":"SMLMData.Emitter3D","text":"Emitter3D{T} <: AbstractEmitter\n\nRepresents a 3D emitter for SMLM simulations with position and brightness.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nz::T: z-coordinate in microns (axial position)\nphotons::T: number of photons emitted by the fluorophore\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter3DFit","page":"API Reference","title":"SMLMData.Emitter3DFit","text":"Emitter3DFit{T} <: AbstractEmitter\n\nRepresents fitted 3D localization results with uncertainties and temporal/tracking information.\n\nFields\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nz::T: fitted z-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_z::T: uncertainty in z position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background in photons/pixel\nframe::Int: frame number in acquisition sequence\ndataset::Int: identifier for specific acquisition/dataset\ntrack_id::Int: identifier for linking localizations across frames (0 = unlinked)\nid::Int: unique identifier within dataset\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter3DFit-Union{Tuple{T}, NTuple{10, T}} where T","page":"API Reference","title":"SMLMData.Emitter3DFit","text":"Emitter3DFit{T}(x, y, z, photons, bg, σ_x, σ_y, σ_z, σ_photons, σ_bg;\n                frame=0, dataset=1, track_id=0, id=0) where T\n\nConvenience constructor for 3D localization fit results with optional identification parameters.\n\nArguments\n\nRequired\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nz::T: fitted z-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_z::T: uncertainty in z position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background level\n\nOptional Keywords\n\nframe::Int=1: frame number in acquisition sequence\ndataset::Int=1: identifier for specific acquisition/dataset\ntrack_id::Int=0: identifier for linking localizations across frames\nid::Int=0: unique identifier within dataset\n\nExample\n\n# Create emitter with just required parameters\nemitter = Emitter3DFit{Float64}(\n    1.0, 2.0, -0.5,  # x, y, z\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01, 0.02,# σ_x, σ_y, σ_z\n    50.0, 2.0        # σ_photons, σ_bg\n)\n\n# Create emitter with specific frame and tracking\nemitter = Emitter3DFit{Float64}(\n    1.0, 2.0, -0.5, 1000.0, 10.0, 0.01, 0.01, 0.02, 50.0, 2.0;\n    frame=5, track_id=1\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera{T} <: AbstractCamera\n\nRepresents an ideal camera with regularly spaced pixels defined by their edges in physical units (microns).\n\nFields\n\npixel_edges_x::Vector{T}: Physical positions of pixel edges in x direction (microns)\npixel_edges_y::Vector{T}: Physical positions of pixel edges in y direction (microns)\n\nThe edges are computed from pixel centers, where pixel (1,1) is centered at  (pixelsizex/2, pixelsizey/2) in physical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(pixel_centers_x::AbstractUnitRange, pixel_centers_y::AbstractUnitRange, \n            pixel_size::Tuple{T, T}) where T<:Real\n\nConstruct an IdealCamera with rectangular pixels given pixel center positions and x,y pixel sizes.\n\nArguments\n\npixel_centers_x::AbstractUnitRange: Range of pixel center indices in x (typically 1:N)\npixel_centers_y::AbstractUnitRange: Range of pixel center indices in y (typically 1:M)\npixel_size::Tuple{T, T}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of the pixel sizes\n\nType Parameters\n\nT: Numeric type for all spatial measurements (e.g., Float64, Float32)\n\nExample\n\n# Create a 512x256 camera with rectangular pixels (0.1 x 0.15 microns)\ncam = IdealCamera(1:512, 1:256, (0.1, 0.15))\n\n# Create with Float32 precision\ncam32 = IdealCamera(1:512, 1:256, (0.1f0, 0.15f0))\n\nNote: Pixel (1,1) is centered at (pixelsize[1]/2, pixelsize[2]/2) in physical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, T}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(pixel_centers_x::AbstractUnitRange, pixel_centers_y::AbstractUnitRange, pixel_size::T) where T<:Real\n\nConstruct an IdealCamera with square pixels given pixel center positions and a scalar pixel size.\n\nArguments\n\npixel_centers_x::AbstractUnitRange: Range of pixel center indices in x (typically 1:N)\npixel_centers_y::AbstractUnitRange: Range of pixel center indices in y (typically 1:M)\npixel_size::Real: Size of pixels in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of pixel_size\n\nType Parameters\n\nT: Numeric type for all spatial measurements (e.g., Float64, Float32)\n\nExample\n\n# Create a 512x512 camera with 0.1 micron square pixels\ncam = IdealCamera(1:512, 1:512, 0.1)\n\n# Create with Float32 precision\ncam32 = IdealCamera(1:512, 1:512, 0.1f0)\n\nNote: Pixel (1,1) is centered at (pixelsize/2, pixelsize/2) in physical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{Integer, Integer, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(n_pixels_x::Integer, n_pixels_y::Integer, pixel_size::Tuple{T, T}) where T<:Real\n\nConstruct an IdealCamera with rectangular pixels directly from the number of pixels and x,y pixel sizes.\n\nArguments\n\nn_pixels_x::Integer: Number of pixels in x dimension\nn_pixels_y::Integer: Number of pixels in y dimension\npixel_size::Tuple{T, T}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of the pixel sizes\n\nExample\n\n# Create a 512x256 camera with rectangular pixels (0.1 x 0.15 microns)\ncam = IdealCamera(512, 256, (0.1, 0.15))\n\n# Create with Float32 precision\ncam32 = IdealCamera(512, 256, (0.1f0, 0.15f0))\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(n_pixels_x::Integer, n_pixels_y::Integer, pixel_size::T) where T<:Real\n\nConstruct an IdealCamera with square pixels directly from the number of pixels and pixel size.\n\nArguments\n\nn_pixels_x::Integer: Number of pixels in x dimension\nn_pixels_y::Integer: Number of pixels in y dimension\npixel_size::Real: Size of pixels in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of pixel_size\n\nExample\n\n# Create a 512x512 camera with 0.1 micron square pixels\ncam = IdealCamera(512, 512, 0.1)\n\n# Create with Float32 precision\ncam32 = IdealCamera(512, 512, 0.1f0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SCMOSCamera","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera{T<:Real} <: AbstractCamera\n\nsCMOS camera with pixel-dependent calibration parameters matching spec sheets.\n\nFields\n\npixel_edges_x::Vector{T}: Physical pixel edges in x (μm)\npixel_edges_y::Vector{T}: Physical pixel edges in y (μm)\noffset::Union{T, Matrix{T}}: Dark level (ADU)\ngain::Union{T, Matrix{T}}: Conversion gain (e⁻/ADU)\nreadnoise::Union{T, Matrix{T}}: Read noise (e⁻ rms)\nqe::Union{T, Matrix{T}}: Quantum efficiency (0-1)\n\nUnits\n\nCalibration parameters follow camera specification sheet conventions:\n\noffset: ADU (analog-to-digital units)\nTypical values: 100-500 ADU\nDark level with no illumination\ngain: e⁻/ADU (electrons per ADU)\nTypical values: 0.1-2.0 e⁻/ADU depending on readout mode\nExample: ORCA-Flash4.0: 0.46 e⁻/ADU (12-bit), 0.11 e⁻/ADU (16-bit)\nreadnoise: e⁻ rms (electrons, root-mean-square)\nTypical values: 0.3-5.0 e⁻ rms\nExample: ORCA-Flash4.0 V3: 1.6 e⁻ rms\nExample: ORCA-Quest qCMOS: 0.27 e⁻ rms\nqe: dimensionless (0 to 1)\nTypical values: 0.5-0.95 at peak wavelength\nExample: ORCA-Flash4.0 V2: 0.72 at 550nm\nExample: ORCA-Fusion BT: 0.95 (back-thinned)\n\nPhysical Signal Chain\n\nPhotons → Electrons → ADU:\n\nIncident photons (N)\n  ↓ [× QE]\nPhotoelectrons (N × QE)\n  ↓ [+ readnoise (Gaussian)]\nSignal electrons (N × QE + ε), where ε ~ N(0, readnoise²)\n  ↓ [÷ gain, + offset]\nADU readout = (N × QE + ε)/gain + offset\n\nScalar vs Matrix Parameters\n\nEach calibration parameter can be:\n\nScalar (T): Uniform across sensor (approximation or post-calibration)\nMatrix (Matrix{T}): Per-pixel calibration map (size must match pixel grid)\n\nUse matrices for:\n\nPrecision SMLM (2-5% variations can affect results)\nQuantitative imaging\nArtifact correction\n\nUse scalars for:\n\nQuick analysis\nPost-calibrated data\nUniform approximation\n\nConstructors\n\n# Minimal - most common case (requires readnoise, others default to 0, 1, 1)\ncam = SCMOSCamera(512, 512, 0.1, 1.6)\n\n# With additional parameters\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                  offset=100.0, gain=0.46, qe=0.72)\n\n# Custom edges (advanced)\ncam = SCMOSCamera(custom_edges_x, custom_edges_y,\n                  readnoise=noise_map, gain=gain_map)\n\nExamples\n\n# Example 1: From spec sheet (ORCA-Flash4.0 V3, 12-bit mode)\ncam = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                 # From spec: 1.6 e⁻ rms readnoise\n    offset = 100.0,      # Typical offset\n    gain = 0.46,         # From spec: 0.46 e⁻/ADU\n    qe = 0.72            # 72% QE at 550nm\n)\n\n# Example 2: With calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\n\ncam = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,\n    gain = gain_map,\n    qe = qe_map\n)\n\n# Example 3: Minimal (variance-only approximation)\n# Common when you only have noise map, assume ideal otherwise\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map)\n\n# Example 4: Ultra-low noise camera (ORCA-Quest)\ncam = SCMOSCamera(\n    2304, 4096, 0.0044,  # 4.4μm pixels\n    0.27,                 # Incredible 0.27 e⁻ rms!\n    offset = 100.0,\n    gain = 0.5,\n    qe = 0.85\n)\n\n# Example 5: Rectangular pixels\ncam = SCMOSCamera(512, 256, (0.1, 0.15), 1.8)\n\n# Example 6: Mixed scalar/matrix parameters\ncam = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5,                     # Uniform gain\n    qe = qe_map                     # Per-pixel QE\n)\n\nSee Also\n\nIdealCamera for Poisson-only noise (readnoise=0)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SCMOSCamera-Union{Tuple{T}, Tuple{Integer, Integer, Union{Tuple{T, T}, T}, Union{Matrix{T}, T}}} where T<:Real","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera(nx, ny, pixel_size, readnoise; offset=0, gain=1, qe=1)\n\nConstruct sCMOS camera from pixel dimensions and calibration parameters.\n\nArguments\n\nnx::Integer: Number of pixels in x\nny::Integer: Number of pixels in y\npixel_size::Union{T, Tuple{T,T}}: Pixel size in μm (scalar or (xsize, ysize))\nreadnoise::Union{T, Matrix{T}}: Read noise in e⁻ rms (required)\n\nKeywords\n\noffset::Union{T, Matrix{T}} = 0: Dark level in ADU\ngain::Union{T, Matrix{T}} = 1: Conversion gain in e⁻/ADU\nqe::Union{T, Matrix{T}} = 1: Quantum efficiency (0-1)\n\nEach parameter can be scalar (uniform) or Matrix{T} with size (nx, ny).\n\nExamples\n\n# Minimal: just readnoise (assumes calibrated data: offset=0, gain=1, qe=1)\ncam = SCMOSCamera(512, 512, 0.1, 1.6)\n\n# From spec sheet (ORCA-Flash4.0 V3)\ncam = SCMOSCamera(2048, 2048, 0.065, 1.6, offset=100.0, gain=0.46, qe=0.72)\n\n# With calibration maps\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                  offset=offset_map, gain=gain_map, qe=qe_map)\n\n# Rectangular pixels\ncam = SCMOSCamera(512, 256, (0.1, 0.15), 1.8)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SCMOSCamera-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Real","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera(pixel_edges_x, pixel_edges_y; offset=0, gain=1, readnoise, qe=1)\n\nConstruct sCMOS camera with custom pixel edge positions.\n\nArguments\n\npixel_edges_x::Vector{T}: Pixel edge positions in x (μm), length nx+1\npixel_edges_y::Vector{T}: Pixel edge positions in y (μm), length ny+1\n\nKeywords\n\nreadnoise::Union{T, Matrix{T}}: Read noise in e⁻ rms (required)\noffset::Union{T, Matrix{T}} = 0: Dark level in ADU\ngain::Union{T, Matrix{T}} = 1: Conversion gain in e⁻/ADU\nqe::Union{T, Matrix{T}} = 1: Quantum efficiency (0-1)\n\nMatrix parameters must have size (nx, ny) where nx = length(pixeledgesx) - 1.\n\nExample\n\n# Custom non-uniform pixel grid\nedges_x = [0.0, 0.1, 0.21, 0.33, 0.46]  # Non-uniform spacing\nedges_y = [0.0, 0.1, 0.2, 0.3]\ncam = SCMOSCamera(edges_x, edges_y, readnoise=1.5, gain=0.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SMLD","page":"API Reference","title":"SMLMData.SMLD","text":"SMLD\n\nAbstract type representing Single Molecule Localization Data (SMLD).\n\nInterface Requirements\n\nAny concrete subtype of SMLD must provide:\n\nemitters::Vector{<:AbstractEmitter}: Vector of localized emitters\n\nAdditional fields may include:\n\nCamera information\nAcquisition parameters\nAnalysis metadata\n\nNote: All emitter coordinates must be in physical units (microns).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SmiteSMD","page":"API Reference","title":"SMLMData.SmiteSMD","text":"SmiteSMD\n\nHelper structure for loading Smite SMD .mat files.\n\nFields\n\nfilepath::String: Path to the directory containing the .mat file\nfilename::String: Name of the .mat file\nvarname::String: Variable name in the .mat file (default: \"SMD\")\n\nExample\n\n# Load from default \"SMD\" variable\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\n\n# Load from custom variable name\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\", \"CustomSMD\")\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SmiteSMLD","page":"API Reference","title":"SMLMData.SmiteSMLD","text":"SmiteSMLD{T,E<:AbstractEmitter} <: SMLD\n\nSMLD type compatible with the Smite SMD (Single Molecule Data) format.\n\nFields\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in the acquisition\nmetadata::Dict{String,Any}: Additional dataset information\n\nType Parameters\n\nT: Numeric type for coordinates (typically Float64)\nE: Concrete emitter type (typically Emitter2DFit or Emitter3DFit)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.iterate-Tuple{SMLD}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(smld::SMLD)\nBase.iterate(smld::SMLD, state)\n\nEnable iteration over emitters in an SMLD object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{SMLD}","page":"API Reference","title":"Base.length","text":"Base.length(smld::SMLD)\n\nReturn the number of emitters in the SMLD object.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.api-Tuple{}","page":"API Reference","title":"SMLMData.api","text":"SMLMData.jl API Overview\n\nThis guide provides a structured overview of the SMLMData.jl package designed for Single Molecule Localization Microscopy (SMLM) data handling in Julia.\n\nWhy This Overview Exists\n\nFor Humans\n\nProvides a concise reference without diving into full documentation\nOffers quick-start examples for common use cases\nShows relevant patterns more clearly than individual docstrings\nCreates an at-a-glance understanding of package capabilities\n\nFor AI Assistants\n\nEnables better code generation with correct API patterns\nProvides structured context about type hierarchies and relationships\nOffers consistent examples to learn from when generating code\nHelps avoid common pitfalls or misunderstandings about the API\n\nKey Concepts\n\nEmitters: Individual fluorophore localizations (2D or 3D)\nCamera: Defines pixel geometry and coordinate system\nSMLD: Container holding emitters and camera information\nCoordinates: All spatial coordinates are in microns\nCoordinate System: \nPhysical space: (0,0) at top-left corner of camera\nPixel space: (1,1) at center of top-left pixel\n\nType Hierarchy\n\nAbstractEmitter                   # Base for all emitter types\n├── Emitter2D{T}                  # Basic 2D emitters\n├── Emitter3D{T}                  # Basic 3D emitters  \n├── Emitter2DFit{T}               # 2D emitters with fit results\n└── Emitter3DFit{T}               # 3D emitters with fit results\n\nAbstractCamera                    # Base for all camera types\n├── IdealCamera{T}                # Camera with regular pixel grid (Poisson noise only)\n└── SCMOSCamera{T}                # sCMOS camera with pixel-dependent calibration\n\nSMLD                              # Base for data containers\n├── BasicSMLD{T,E}                # General-purpose container\n└── SmiteSMLD{T,E}                # SMITE-compatible container\n\nEssential Types\n\nEmitter Types\n\n# Basic 2D emitter\nmutable struct Emitter2D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\n# Basic 3D emitter\nmutable struct Emitter3D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    z::T           # z-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\n# 2D emitter with fit results\nmutable struct Emitter2DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\n# 3D emitter with fit results\nmutable struct Emitter3DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    z::T           # fitted z-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_z::T         # uncertainty in z position in microns\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\nEmitter Constructor Examples\n\n# Basic 2D emitter\nemitter_2d = Emitter2D{Float64}(\n    1.5,      # x-coordinate in microns\n    2.3,      # y-coordinate in microns  \n    1000.0    # number of photons emitted\n)\n\n# Basic 3D emitter\nemitter_3d = Emitter3D{Float64}(\n    1.5,      # x-coordinate in microns\n    2.3,      # y-coordinate in microns\n    -0.5,     # z-coordinate in microns (negative = below focal plane)\n    1000.0    # number of photons emitted\n)\n\n# 2D emitter with fit results using convenience constructor\nemitter_2d_fit = Emitter2DFit{Float64}(\n    1.5, 2.3,        # x, y coordinates in microns\n    1000.0, 10.0,    # photons detected, background photons/pixel\n    0.01, 0.01,      # σ_x, σ_y: position uncertainties in microns\n    50.0, 2.0;       # σ_photons, σ_bg: photon count uncertainties\n    frame=5,         # frame number in acquisition (1-based, default=1)\n    dataset=1,       # dataset identifier for multi-acquisition experiments\n    track_id=2,      # tracking ID for linked localizations (default=0 = unlinked)\n    id=42            # unique identifier within this dataset (default=0)\n)\n\nCamera Types\n\n# Ideal camera with uniform pixel grid (Poisson noise only)\nstruct IdealCamera{T} <: AbstractCamera\n    pixel_edges_x::Vector{T}  # pixel edges in x\n    pixel_edges_y::Vector{T}  # pixel edges in y\nend\n\n# sCMOS camera with pixel-dependent calibration parameters\nstruct SCMOSCamera{T} <: AbstractCamera\n    pixel_edges_x::Vector{T}      # pixel edges in x\n    pixel_edges_y::Vector{T}      # pixel edges in y\n    offset::Union{T, Matrix{T}}   # dark level (ADU)\n    gain::Union{T, Matrix{T}}     # conversion gain (e⁻/ADU)\n    readnoise::Union{T, Matrix{T}}  # read noise (e⁻ rms)\n    qe::Union{T, Matrix{T}}       # quantum efficiency (0-1)\nend\n\nCamera Constructor Examples\n\n# IdealCamera: Create a camera with 512x512 pixels, each 100nm (0.1μm) in size\n# Convenience constructor (most common)\ncam = IdealCamera(512, 512, 0.1)\n\n# Explicit constructor using pixel center ranges\ncam_explicit = IdealCamera(1:512, 1:512, 0.1)\n\n# For non-square pixels, specify different x and y sizes\ncam_rect = IdealCamera(512, 512, (0.1, 0.12))\n\n# SCMOSCamera: Create with readnoise specification (matching spec sheets)\n# Minimal (uniform readnoise, assumes offset=0, gain=1, qe=1)\ncam_scmos = SCMOSCamera(512, 512, 0.1, 1.6)  # 1.6 e⁻ rms readnoise\n\n# From camera spec sheet (e.g., ORCA-Flash4.0 V3)\ncam_flash = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                # 1.6 e⁻ rms readnoise from spec\n    offset = 100.0,     # typical dark level\n    gain = 0.46,        # 0.46 e⁻/ADU from spec\n    qe = 0.72           # 72% QE at 550nm\n)\n\n# With per-pixel calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\ncam_calibrated = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                              gain=gain_map, qe=qe_map)\n\n# Mixed scalar and matrix parameters\ncam_mixed = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5,                     # Uniform gain\n    qe = qe_map                     # Per-pixel QE\n)\n\nSMLD Container Types\n\n# Basic SMLD container\nstruct BasicSMLD{T,E<:AbstractEmitter} <: SMLD\n    emitters::Vector{E}        # Vector of emitters\n    camera::AbstractCamera     # Camera information\n    n_frames::Int              # Total number of frames\n    n_datasets::Int            # Number of datasets\n    metadata::Dict{String,Any} # Additional information\nend\n\n# SMITE format compatible container\nstruct SmiteSMLD{T,E<:AbstractEmitter} <: SMLD\n    emitters::Vector{E}        # Vector of emitters\n    camera::AbstractCamera     # Camera information\n    n_frames::Int              # Total number of frames\n    n_datasets::Int            # Number of datasets\n    metadata::Dict{String,Any} # Additional information\nend\n\nSMLD Constructor Examples\n\n# Create a vector of emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n]\n\n# Create a BasicSMLD\nsmld = BasicSMLD(emitters, camera, 1, 1, Dict{String,Any}())\n\n# Add metadata\nsmld_with_metadata = BasicSMLD(\n    emitters, \n    camera, \n    10,  # number of frames\n    1,   # number of datasets\n    Dict{String,Any}(\n        \"exposure_time\" => 0.1,\n        \"sample\" => \"Test Sample\"\n    )\n)\n\nCore Functions\n\nAccessing the API Overview\n\n# Get this API overview as a string programmatically\noverview_text = api_overview()\n\nCoordinate Conversions\n\n# Convert from pixel to physical coordinates (microns)\nx_physical, y_physical = pixel_to_physical(px, py, pixel_size)\n\n# Convert from physical to pixel coordinates\npx, py = physical_to_pixel(x, y, pixel_size)\n\n# Convert from physical to pixel indices (integers)\npx_idx, py_idx = physical_to_pixel_index(x, y, pixel_size)\n\n# Get physical coordinates of all pixel centers\ncenters_x, centers_y = get_pixel_centers(camera)\n\nFiltering Operations\n\n# Filter by emitter properties using @filter macro\nbright = @filter(smld, photons > 1000)                     # Select bright emitters\nprecise = @filter(smld, σ_x < 0.02 && σ_y < 0.02)         # Select precisely localized emitters\ncombined = @filter(smld, photons > 1000 && σ_x < 0.02)     # Combine multiple criteria\n\n# The @filter macro supports any emitter property:\n# - Basic: x, y, z (for 3D), photons\n# - Fit results: bg, σ_x, σ_y, σ_z, σ_photons, σ_bg\n# - Metadata: frame, dataset, track_id, id\n\n# Select frames\nframe_5 = filter_frames(smld, 5)                  # Single frame\nearly_frames = filter_frames(smld, 1:10)          # Range of frames (inclusive)\nspecific_frames = filter_frames(smld, [1,3,5,7])  # Specific frames (uses Set for efficiency)\n\n# Select region of interest (ROI) - coordinates in microns\n# 2D ROI\nroi_2d = filter_roi(smld, 1.0:5.0, 2.0:6.0)       # x_range, y_range\n\n# 3D ROI (for 3D emitters only)\nroi_3d = filter_roi(smld, 1.0:5.0, 2.0:6.0, -1.0:1.0)  # x, y, z ranges\n\nSMLD Operations\n\n# Concatenate multiple SMLDs\ncombined = cat_smld(smld1, smld2)\ncombined = cat_smld([smld1, smld2, smld3])\n\n# Merge with options to adjust frame and dataset numbering\nmerged = merge_smld(smld1, smld2)\nmerged = merge_smld([smld1, smld2, smld3])\n\n# Merge with sequential frame numbers\nsequential = merge_smld([smld1, smld2, smld3], adjust_frames=true)\n\n# Merge with sequential dataset numbers\nsequential_ds = merge_smld([smld1, smld2, smld3], adjust_datasets=true)\n\nI/O Operations\n\n# Import from SMITE format (MATLAB)\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")  # Default variable name \"SMD\"\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\", \"CustomSMD\")  # Custom variable name\n\n# Load as 2D or 3D data\nsmld_2d = load_smite_2d(smd)\nsmld_3d = load_smite_3d(smd)\n\n# Export to SMITE format (saved as MATLAB v7.3 format)\n# Note: requires SmiteSMLD object, not BasicSMLD\nsmite_smld = SmiteSMLD(smld.emitters, smld.camera, smld.n_frames, smld.n_datasets, smld.metadata)\nsave_smite(smite_smld, \"output/directory\", \"results.mat\")\n\nNote: The SMITE loader automatically handles complex-valued fields by removing emitters with non-zero imaginary components in key fields (X, Y, Z, Photons, background, and uncertainties). Information about removed emitters is stored in the metadata as \"removed_complex_emitters\" => count.\n\nWorking with SMLD Objects\n\n# Get number of emitters\nn_emitters = length(smld)\n\n# Iterate over emitters\nfor emitter in smld\n    println(\"Emitter at ($(emitter.x), $(emitter.y)) with $(emitter.photons) photons\")\nend\n\n# Display formatted information\nshow(smld)  # Compact view\nshow(stdout, MIME(\"text/plain\"), smld)  # Detailed view\n\nCommon Workflows\n\nCreating and Working with Emitters\n\n# Create emitters\nemitter1 = Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0)\nemitter2 = Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n\n# Create camera\ncam = IdealCamera(512, 512, 0.1)  # 512x512 camera with 0.1 micron pixels\n\n# Create SMLD container\nemitters = [emitter1, emitter2]\nsmld = BasicSMLD(emitters, cam, 1, 1, Dict{String,Any}())\n\nLoading and Filtering Data\n\n# Load from SMITE format\nsmd = SmiteSMD(\"data_directory\", \"localizations.mat\")\nsmld = load_smite_2d(smd)\n\n# Filter by quality\ngood_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02 && photons > 500)\n\n# Filter by ROI\nroi = filter_roi(good_fits, 10.0:20.0, 10.0:20.0)\n\n# Filter by frames\nframes_1_10 = filter_frames(roi, 1:10)\n\nMulti-Dataset Analysis\n\n# Load multiple datasets\nsmd1 = SmiteSMD(\"experiment1\", \"data.mat\")\nsmd2 = SmiteSMD(\"experiment2\", \"data.mat\")\nsmld1 = load_smite_2d(smd1)\nsmld2 = load_smite_2d(smd2)\n\n# Filter each dataset\nbright1 = @filter(smld1, photons > 1000)\nbright2 = @filter(smld2, photons > 1000)\n\n# Merge datasets with sequential frame numbering\nmerged = merge_smld([bright1, bright2], adjust_frames=true)\n\n# Process the merged dataset\nresult = @filter(merged, σ_x < 0.02 && σ_y < 0.02)\n\n# Save the results (convert to SmiteSMLD first if needed)\nresult_smite = SmiteSMLD(result.emitters, result.camera, result.n_frames, result.n_datasets, result.metadata)\nsave_smite(result_smite, \"analysis_results\", \"merged_filtered.mat\")\n\nComplete Example\n\nusing SMLMData\n\n# 1. Create a camera with 100nm pixels\n# Camera has 512x512 pixels, each 0.1 microns (100nm) in size\ncam = IdealCamera(512, 512, 0.1)  # Using convenience constructor  \n\n# 2. Create emitters representing single molecule localizations\nemitters = [\n    # Emitter at (1.0, 2.0) μm with high precision\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    \n    # Bright emitter at (3.0, 4.0) μm\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0),\n    \n    # Dimmer emitter at (5.0, 6.0) μm with lower precision\n    Emitter2DFit{Float64}(5.0, 6.0, 800.0, 9.0, 0.03, 0.03, 40.0, 1.5)\n]\n\n# 3. Create SMLD container to hold all data\nsmld = BasicSMLD(\n    emitters,                              # Vector of emitters\n    cam,                                   # Camera geometry\n    1,                                     # Number of frames\n    1,                                     # Number of datasets\n    Dict{String,Any}(\"sample\" => \"Test\")   # Metadata\n)\n\n# 4. Filter by photons to select bright emitters\nbright = @filter(smld, photons > 900)      # Creates new SMLD with filtered emitters\n\n# 5. Select region of interest (ROI)\n# Select emitters in rectangular region: x ∈ [0, 4] μm, y ∈ [1, 5] μm\nroi = filter_roi(bright, 0.0:4.0, 1.0:5.0)\n\n# 6. Examine the results\nprintln(\"Original dataset: $(length(smld)) emitters\")\nprintln(\"After filtering by brightness: $(length(bright)) emitters\")\nprintln(\"After ROI selection: $(length(roi)) emitters\")\n\n# 7. Access individual emitters\nfor (i, emitter) in enumerate(roi)\n    println(\"Emitter $i: position=($(emitter.x), $(emitter.y)) μm, photons=$(emitter.photons)\")\nend\n\n# Output:\n# Original dataset: 3 emitters\n# After filtering by brightness: 2 emitters\n# After ROI selection: 2 emitters\n# Emitter 1: position=(1.0, 2.0) μm, photons=1000.0\n# Emitter 2: position=(3.0, 4.0) μm, photons=1200.0\n\nCommon Pitfalls and Important Notes\n\nCoordinate System\n\nPhysical coordinates are always in microns, not nanometers or pixels\nPixel indices start at 1 (Julia convention), not 0\nFrame numbers start at 1 (default=1, following Julia's 1-based indexing convention)\nThe origin (0,0) in physical space is at the top-left corner of the camera\n\nType Stability\n\nWhen creating emitters, ensure all numeric fields use the same type (e.g., all Float64)\nThe BasicSMLD constructor automatically infers type T from the camera's pixel edges\nMixing types (e.g., Float32 and Float64) can lead to performance issues\n\nFiltering\n\nThe @filter macro creates a new SMLD object; it doesn't modify the original\nFiltering by frames with a vector uses Set internally for O(1) lookup performance\nApplying a 3D ROI filter to 2D emitters will throw an error\n\nSMITE Format\n\nComplex-valued fields in SMITE files are automatically handled by removing affected emitters\nThe loader adds metadata about removed emitters: \"removed_complex_emitters\" => count\nSMITE files are saved in MATLAB v7.3 format (HDF5-based)\n\nMemory Considerations\n\nLarge datasets benefit from using appropriate numeric types (e.g., Float32 vs Float64)\nThe filter_frames function with specific frame lists is optimized for sparse selections\nIterating over emitters is memory-efficient (doesn't create intermediate arrays)\n\nCommon Mistakes\n\n# WRONG: Using pixel units instead of microns\nemitter = Emitter2D{Float64}(100, 200, 1000.0)  # ❌ Likely pixel coordinates\n\n# CORRECT: Using micron coordinates\nemitter = Emitter2D{Float64}(10.0, 20.0, 1000.0)  # ✓ Physical coordinates\n\n# WRONG: Modifying original SMLD\nbright = @filter(smld, photons > 1000)\n# smld is unchanged!\n\n# CORRECT: Working with the filtered result\nbright = @filter(smld, photons > 1000)\n# Use 'bright' for further analysis\n\n\n\napi() returns this documentation as a plain String.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.cat_smld-Tuple{Vector{<:SMLD}}","page":"API Reference","title":"SMLMData.cat_smld","text":"cat_smld(smlds::Vector{<:SMLD})\ncat_smld(smlds::SMLD...)\n\nConcatenate multiple SMLD objects into a single SMLD.\n\nArguments\n\nsmlds: Vector of SMLD objects or multiple SMLD arguments\n\nReturns\n\nNew SMLD containing all emitters from inputs\n\nNotes\n\nCamera must be identical across all SMLDs\nn_frames is set to maximum frame number across all inputs\nn_datasets is set to maximum dataset number across all inputs\nMetadata from first SMLD is used, with conflicts noted in metadata\n\nExamples\n\n# Concatenate two SMLDs\ncombined = cat_smld(smld1, smld2)\n\n# Concatenate multiple SMLDs\ncombined = cat_smld(smld1, smld2, smld3)\n\n# Concatenate vector of SMLDs\ncombined = cat_smld([smld1, smld2, smld3])\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.check_complex_fields-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.check_complex_fields","text":"check_complex_fields(s, fields)\n\nCheck if any of the given fields in s are complex and have non-zero imaginary components. Returns a tuple with:\n\nBoolean indicating if any fields are complex with non-zero imaginary parts\nDict mapping field names to arrays of indices with non-zero imaginary parts\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_bin_edges-Tuple{AbstractUnitRange, AbstractUnitRange, Tuple{Real, Real}}","page":"API Reference","title":"SMLMData.compute_bin_edges","text":"compute_bin_edges(centers_x::AbstractUnitRange, centers_y::AbstractUnitRange, pixel_size::Tuple{Real, Real})\n\nCompute pixel edges in both dimensions for rectangular pixels.\n\nArguments\n\ncenters_x::AbstractUnitRange: Range of pixel center indices in x\ncenters_y::AbstractUnitRange: Range of pixel center indices in y\npixel_size::Tuple{Real, Real}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: (edgesx, edgesy) in physical units (microns)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_bin_edges-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, T}} where T","page":"API Reference","title":"SMLMData.compute_bin_edges","text":"compute_bin_edges(centers_x::AbstractUnitRange, centers_y::AbstractUnitRange, pixel_size::T) where T\n\nCompute pixel edges in both dimensions. Returns vectors with same type as pixel_size.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_edges_1d-Union{Tuple{T}, Tuple{AbstractUnitRange, T}} where T<:Real","page":"API Reference","title":"SMLMData.compute_edges_1d","text":"compute_edges_1d(centers::AbstractUnitRange, pixel_size::T) where T<:Real\n\nCompute pixel edges in one dimension. Maintains the numeric type of pixelsize. The first edge starts at 0 and each pixel has width pixelsize.\n\nArguments\n\ncenters::AbstractUnitRange: Range of pixel center indices\npixel_size::T: Size of pixels in microns\n\nReturns\n\nVector{T}: Edge positions in physical units (microns), starting at 0\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.filter_frames-Tuple{SMLD, Integer}","page":"API Reference","title":"SMLMData.filter_frames","text":"filter_frames(smld::SMLD, frame::Integer)\nfilter_frames(smld::SMLD, frames::Union{AbstractVector,AbstractRange})\n\nEfficiently select emitters from specified frames.\n\nArguments\n\nsmld::SMLD: Input SMLD structure\nframes: Single frame number, vector of frame numbers, or range of frames\n\nReturns\n\nNew SMLD containing only emitters from specified frames\n\nExamples\n\n# Single frame\nframe_5 = filter_frames(smld, 5)\n\n# Range of frames\nearly = filter_frames(smld, 1:10)\n\n# Multiple specific frames\nselected = filter_frames(smld, [1,3,5,7])\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.filter_roi-Tuple{SMLD, Any, Any}","page":"API Reference","title":"SMLMData.filter_roi","text":"filter_roi(smld::SMLD, x_range, y_range)\nfilter_roi(smld::SMLD, x_range, y_range, z_range)\n\nEfficiently select emitters within a region of interest.\n\nArguments\n\nsmld::SMLD: Input SMLD structure\nx_range: Range or tuple for x coordinates (microns)\ny_range: Range or tuple for y coordinates (microns)\nz_range: Optional range or tuple for z coordinates (microns)\n\nReturns\n\nNew SMLD containing only emitters within the specified ROI\n\nExamples\n\n# 2D ROI\nregion = filter_roi(smld, 1.0:5.0, 2.0:6.0)\nregion = filter_roi(smld, (1.0, 5.0), (2.0, 6.0))\n\n# 3D ROI\nvolume = filter_roi(smld, 1.0:5.0, 2.0:6.0, -1.0:1.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.format_with_commas-Tuple{Integer}","page":"API Reference","title":"SMLMData.format_with_commas","text":"format_with_commas(n::Integer)\n\nFormat an integer with thousands separators for better readability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_gain-Union{Tuple{T}, Tuple{SCMOSCamera{T}, Int64, Int64}} where T","page":"API Reference","title":"SMLMData.get_gain","text":"get_gain(camera, i, j) -> T\n\nGet gain value at pixel (i,j), handling both scalar and matrix parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_offset-Union{Tuple{T}, Tuple{SCMOSCamera{T}, Int64, Int64}} where T","page":"API Reference","title":"SMLMData.get_offset","text":"get_offset(camera, i, j) -> T\n\nGet offset value at pixel (i,j), handling both scalar and matrix parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_pixel_centers-Tuple{AbstractCamera}","page":"API Reference","title":"SMLMData.get_pixel_centers","text":"get_pixel_centers(cam::AbstractCamera)\n\nCalculate the physical coordinates of all pixel centers for any camera type.\n\nFor each dimension, the center positions are computed as the midpoint between  consecutive edge positions. This works for both regular (uniform pixel size)  and irregular (varying pixel size) cameras.\n\nArguments\n\ncam::AbstractCamera: Any camera type that implements the AbstractCamera interface with pixeledgesx and pixeledgesy fields in physical units (microns)\n\nReturns\n\nTuple{Vector, Vector}: (centersx, centersy) where each vector contains the physical  coordinates (in microns) of pixel centers along that dimension\n\nExample\n\n# For a 512x512 camera with 0.1 micron pixels\ncam = IdealCamera(1:512, 1:512, 0.1)\ncenters_x, centers_y = get_pixel_centers(cam)\n\n# First pixel center should be at (0.05, 0.05) microns\n@assert centers_x[1] ≈ 0.05\n@assert centers_y[1] ≈ 0.05\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_qe-Union{Tuple{T}, Tuple{SCMOSCamera{T}, Int64, Int64}} where T","page":"API Reference","title":"SMLMData.get_qe","text":"get_qe(camera, i, j) -> T\n\nGet quantum efficiency at pixel (i,j), handling both scalar and matrix parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_readnoise-Union{Tuple{T}, Tuple{SCMOSCamera{T}, Int64, Int64}} where T","page":"API Reference","title":"SMLMData.get_readnoise","text":"get_readnoise(camera, i, j) -> T\n\nGet readnoise (e⁻ rms) at pixel (i,j), handling both scalar and matrix parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_readnoise_var-Union{Tuple{T}, Tuple{SCMOSCamera{T}, Int64, Int64}} where T","page":"API Reference","title":"SMLMData.get_readnoise_var","text":"get_readnoise_var(camera, i, j) -> T\n\nGet readnoise variance (e⁻²) at pixel (i,j), computed from readnoise rms.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_valid_indices-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.get_valid_indices","text":"get_valid_indices(s, complex_indices)\n\nGet indices of elements that don't have complex values with non-zero imaginary parts in any field.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.has_nonzero_imag-Tuple{Any}","page":"API Reference","title":"SMLMData.has_nonzero_imag","text":"has_nonzero_imag(value)\n\nCheck if a value has a non-zero imaginary component. Works for both scalar values and arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.load_smite_2d-Tuple{SmiteSMD}","page":"API Reference","title":"SMLMData.load_smite_2d","text":"load_smite_2d(smd::SmiteSMD)\n\nLoad a 2D Smite SMD .mat file and convert it to SmiteSMLD format. Checks for complex fields and removes emitters with non-zero imaginary components.\n\nArguments\n\nsmd::SmiteSMD: SmiteSMD object specifying the file to load\n\nReturns\n\nSmiteSMLD containing 2D localizations\n\nNotes\n\nAll spatial coordinates are converted to microns\nIf PixelSize is not specified in the file, defaults to 0.1 microns\nEmitters with non-zero imaginary components will be excluded with a warning\nFields are converted from Float32 to Float64 as needed\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.load_smite_3d-Tuple{SmiteSMD}","page":"API Reference","title":"SMLMData.load_smite_3d","text":"load_smite_3d(smd::SmiteSMD)\n\nLoad a 3D Smite SMD .mat file and convert it to SmiteSMLD format. Checks for complex fields and removes emitters with non-zero imaginary components.\n\nArguments\n\nsmd::SmiteSMD: SmiteSMD object specifying the file to load\n\nReturns\n\nSmiteSMLD containing 3D localizations\n\nNotes\n\nAll spatial coordinates are converted to microns\nIf PixelSize is not specified in the file, defaults to 0.1 microns\nEmitters with non-zero imaginary components will be excluded with a warning\nFields are converted from Float32 to Float64 as needed\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.merge_smld-Tuple{Vector{<:SMLD}}","page":"API Reference","title":"SMLMData.merge_smld","text":"merge_smld(smlds::Vector{<:SMLD}; adjust_frames=false, adjust_datasets=false)\nmerge_smld(smlds::SMLD...; adjust_frames=false, adjust_datasets=false)\n\nMerge multiple SMLD objects with options to adjust frame and dataset numbering.\n\nArguments\n\nsmlds: Vector of SMLD objects or multiple SMLD arguments\nadjust_frames: If true, adjusts frame numbers to be sequential\nadjust_datasets: If true, adjusts dataset numbers to be sequential\n\nReturns\n\nNew SMLD containing all emitters with adjusted numbering if requested\n\nNotes\n\nCamera must be identical across all SMLDs\nWhen adjust_frames=true, frame numbers are made sequential across all inputs\nWhen adjust_datasets=true, dataset numbers are made sequential\nMetadata includes information about the merge operation\n\nExamples\n\n# Simple merge\nmerged = merge_smld(smld1, smld2)\n\n# Merge with frame number adjustment\nmerged = merge_smld(smld1, smld2, adjust_frames=true)\n\n# Merge multiple with both adjustments\nmerged = merge_smld([smld1, smld2, smld3], \n                   adjust_frames=true, \n                   adjust_datasets=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.physical_to_pixel-Tuple{Real, Real, Real}","page":"API Reference","title":"SMLMData.physical_to_pixel","text":"physical_to_pixel(x::Real, y::Real, pixel_size::Real)\n\nConvert physical coordinates (in microns) to pixel coordinates.\n\nArguments\n\nx::Real: x coordinate in microns (0,0 is top-left of image)\ny::Real: y coordinate in microns (0,0 is top-left of image)\npixel_size::Real: size of a pixel in microns\n\nReturns\n\nTuple{Float64, Float64}: (px,py) pixel coordinates where (1,1) is center of top-left pixel\n\nExample\n\n# For a camera with 0.1 micron pixels\npx, py = physical_to_pixel(0.05, 0.05, 0.1)  # Point 0.05,0.05 microns from origin\n# Returns (1.0, 1.0) - center of first pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.physical_to_pixel_index-Tuple{Real, Real, Real}","page":"API Reference","title":"SMLMData.physical_to_pixel_index","text":"physical_to_pixel_index(x::Real, y::Real, pixel_size::Real)\n\nConvert physical coordinates (in microns) to integer pixel indices. Returns the pixel that contains the given physical coordinate.\n\nArguments\n\nx::Real: x coordinate in microns (0,0 is top-left of image)\ny::Real: y coordinate in microns (0,0 is top-left of image)\npixel_size::Real: size of a pixel in microns\n\nReturns\n\nTuple{Int, Int}: (px,py) pixel indices where (1,1) is top-left pixel\n\nExample\n\n# For a camera with 0.1 micron pixels\npx, py = physical_to_pixel_index(0.05, 0.05, 0.1)  # Point at center of first pixel\n# Returns (1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.pixel_to_physical-Union{Tuple{T}, Tuple{Real, Real, T}} where T","page":"API Reference","title":"SMLMData.pixel_to_physical","text":"pixel_to_physical(px::Real, py::Real, pixel_size::T) where T\n\nConvert pixel coordinates to physical coordinates (in microns). Returns coordinates with the same type as pixel_size.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.save_smite-Tuple{SmiteSMLD, String, String}","page":"API Reference","title":"SMLMData.save_smite","text":"save_smite(smld::SmiteSMLD, filepath::String, filename::String)\n\nSave SmiteSMLD data back to SMITE's SMD .mat format.\n\nArguments\n\nsmld::SmiteSMLD: SMLD object to save\nfilepath::String: Directory path where to save the file\nfilename::String: Name of the output .mat file\n\nNotes\n\nSaves in MATLAB v7.3 format\nPreserves all metadata fields\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.@filter-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.@filter","text":"@filter(smld, condition)\n\nFilter SMLD emitters using a natural condition syntax. Transforms expressions at compile time into efficient filtering operations.\n\nExamples\n\n# Simple conditions\nbright = @filter(smld, photons > 1000)\nearly = @filter(smld, frame < 10)\n\n# Compound conditions\ngood_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02)\nroi = @filter(smld, 1.0 <= x <= 5.0 && 1.0 <= y <= 5.0)\n\n\n\n\n\n","category":"macro"},{"location":"#SMLMData.jl","page":"Home","title":"SMLMData.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Data types and utilities for Single Molecule Localization Microscopy (SMLM) in Julia.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SMLMData.jl provides core data structures and operations for working with Single Molecule Localization Microscopy data. The package follows a type-based design that makes it easy to represent, manipulate, and analyze localization data.","category":"page"},{"location":"#Emitters","page":"Home","title":"Emitters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Emitters represent individual fluorophore localizations in single molecule localization microscopy. SMLMData provides several emitter types to accommodate different analysis needs.","category":"page"},{"location":"#Emitter-Type-Hierarchy","page":"Home","title":"Emitter Type Hierarchy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All emitter types derive from the abstract AbstractEmitter base type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractEmitter\n ├─ Emitter2D{T}      - Basic 2D emitter with position and photons\n ├─ Emitter3D{T}      - Basic 3D emitter with position and photons\n ├─ Emitter2DFit{T}   - 2D emitter with fit results and uncertainties\n └─ Emitter3DFit{T}   - 3D emitter with fit results and uncertainties","category":"page"},{"location":"#Basic-Emitter-Types","page":"Home","title":"Basic Emitter Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most basic emitter types store only position and photon count:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct Emitter2D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\nstruct Emitter3D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    z::T           # z-coordinate in microns\n    photons::T     # number of photons emitted\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types are useful for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulating fluorophore emissions\nRepresenting ground truth data\nSimple visualization scenarios","category":"page"},{"location":"#Fit-Result-Emitter-Types","page":"Home","title":"Fit Result Emitter Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For real data analysis, SMLMData provides extended emitter types that include fit results with uncertainties and tracking information:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mutable struct Emitter2DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\nmutable struct Emitter3DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    z::T           # fitted z-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_z::T         # uncertainty in z position in microns\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types are suitable for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Storing localization analysis results\nQuality control and filtering\nTracking and trajectory analysis\nMulti-dataset analysis","category":"page"},{"location":"#Creating-Emitters","page":"Home","title":"Creating Emitters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Basic 2D emitter\nemitter_2d = Emitter2D{Float64}(1.5, 2.3, 1000.0)  # x, y, photons\n\n# Basic 3D emitter\nemitter_3d = Emitter3D{Float64}(1.5, 2.3, -0.5, 1000.0)  # x, y, z, photons\n\n# 2D emitter with fit results using convenience constructor\nemitter_2d_fit = Emitter2DFit{Float64}(\n    1.5, 2.3,        # x, y coordinates (μm)\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01,      # σ_x, σ_y (uncertainties in μm)\n    50.0, 2.0;       # σ_photons, σ_bg (uncertainties)\n    frame=5,         # frame number\n    dataset=1,       # dataset identifier\n    track_id=2,      # tracking identifier (0 = unlinked)\n    id=42            # unique identifier\n)\n\n# 3D emitter with fit results\nemitter_3d_fit = Emitter3DFit{Float64}(\n    1.5, 2.3, -0.5,    # x, y, z coordinates (μm)\n    1000.0, 10.0,      # photons, background\n    0.01, 0.01, 0.02,  # σ_x, σ_y, σ_z (uncertainties in μm)\n    50.0, 2.0;         # σ_photons, σ_bg (uncertainties)\n    frame=5,           # frame number\n    dataset=1,         # dataset identifier\n    track_id=2,        # tracking identifier (0 = unlinked)\n    id=42              # unique identifier\n)","category":"page"},{"location":"#Type-Parameter","page":"Home","title":"Type Parameter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All emitter types use a type parameter T to specify the numeric precision:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Float64 precision (default)\nemitter_f64 = Emitter2D{Float64}(1.0, 2.0, 1000.0)\n\n# Float32 precision for reduced memory usage\nemitter_f32 = Emitter2D{Float32}(1.0f0, 2.0f0, 1000.0f0)","category":"page"},{"location":"#Cameras","page":"Home","title":"Cameras","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Cameras define the imaging system's geometry and handling of pixel coordinates.","category":"page"},{"location":"#Camera-Types","page":"Home","title":"Camera Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SMLMData provides two camera types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IdealCamera: For detectors with Poisson noise only (e.g., EMCCD in photon-counting mode)\nSCMOSCamera: For sCMOS detectors with pixel-dependent calibration parameters","category":"page"},{"location":"#IdealCamera","page":"Home","title":"IdealCamera","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create a camera with 512x512 pixels, each 100nm (0.1μm) in size\ncamera = IdealCamera(512, 512, 0.1)\n\n# For non-square pixels, specify different x and y sizes\ncamera_rect = IdealCamera(512, 512, (0.1, 0.12))","category":"page"},{"location":"#SCMOSCamera","page":"Home","title":"SCMOSCamera","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Minimal: uniform readnoise (assumes offset=0, gain=1, qe=1)\ncam_scmos = SCMOSCamera(512, 512, 0.1, 1.6)  # 1.6 e⁻ rms readnoise\n\n# From camera spec sheet (e.g., ORCA-Flash4.0 V3)\ncam_flash = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                 # 1.6 e⁻ rms readnoise from spec\n    offset = 100.0,      # typical dark level (ADU)\n    gain = 0.46,         # 0.46 e⁻/ADU from spec\n    qe = 0.72            # 72% QE at 550nm\n)\n\n# With per-pixel calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\ncam_calibrated = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                              gain=gain_map, qe=qe_map)\n\n# Mixed scalar and matrix parameters\ncam_mixed = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5                      # Uniform gain\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SCMOSCamera Parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"offset: Dark level in ADU (analog-to-digital units)\ngain: Conversion gain in e⁻/ADU (electrons per ADU)\nreadnoise: Read noise in e⁻ rms (root-mean-square, matches spec sheets)\nqe: Quantum efficiency (dimensionless, 0-1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each parameter can be:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scalar: Uniform value across the sensor\nMatrix: Per-pixel calibration map (size must match pixel grid)","category":"page"},{"location":"#Coordinate-Conventions","page":"Home","title":"Coordinate Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All spatial coordinates are in microns\nPhysical space: (0,0) at top-left corner of camera\nPixel space: (1,1) at center of top-left pixel","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Convert between coordinate systems\nx_physical, y_physical = pixel_to_physical(10.5, 15.5, 0.1)\npx, py = physical_to_pixel(1.05, 1.55, 0.1)","category":"page"},{"location":"#SMLD","page":"Home","title":"SMLD","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SMLD (Single Molecule Localization Data) is the container type that holds emitters and camera information.","category":"page"},{"location":"#Creating-an-SMLD","page":"Home","title":"Creating an SMLD","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create a vector of emitters\nemitters = [\n    Emitter2D{Float64}(1.0, 2.0, 1000.0),\n    Emitter2D{Float64}(3.0, 4.0, 1200.0)\n]\n\n# Create a BasicSMLD\nsmld = BasicSMLD(emitters, camera, 1, 1, Dict{String,Any}())\n\n# Add metadata\nsmld_with_metadata = BasicSMLD(\n    emitters, \n    camera, \n    10,  # number of frames\n    1,   # number of datasets\n    Dict{String,Any}(\n        \"exposure_time\" => 0.1,\n        \"sample\" => \"Test Sample\"\n    )\n)","category":"page"},{"location":"#Filtering-Operations","page":"Home","title":"Filtering Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Filter by emitter properties\nbright_emitters = @filter(smld, photons > 1000)\nprecise_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02)\n\n# Select region of interest\nregion = filter_roi(smld, 0.0:2.0, 1.0:3.0)\n\n# Select frames\nframe_5 = filter_frames(smld, 5)\nearly_frames = filter_frames(smld, 1:10)","category":"page"},{"location":"#Combining-SMLDs","page":"Home","title":"Combining SMLDs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Concatenate two SMLD objects\ncombined = cat_smld(smld1, smld2)\n\n# Merge with sequential frame numbering\nmerged = merge_smld([smld1, smld2], adjust_frames=true)","category":"page"},{"location":"#File-I/O","page":"Home","title":"File I/O","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SMLMData currently supports the SMITE format, with more formats planned for future releases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Import from SMITE format (MATLAB)\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\nsmld_2d = load_smite_2d(smd)\nsmld_3d = load_smite_3d(smd)\n\n# Export to SMITE format\nsave_smite(smld, \"output/directory\", \"results.mat\")","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SMLMData\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For complete API documentation, see the API Reference.","category":"page"},{"location":"io/#File-I/O","page":"Saving and Loading","title":"File I/O","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"SMLMData provides functionality for importing and exporting localization data in various formats. This page documents the currently supported formats and related functions.","category":"page"},{"location":"io/#SMITE-Format","page":"Saving and Loading","title":"SMITE Format","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"SMITE is a MATLAB-based format commonly used in single molecule localization microscopy. SMLMData provides types and functions for interfacing with this format.","category":"page"},{"location":"io/#Types","page":"Saving and Loading","title":"Types","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"# Helper type for loading SMITE .mat files\nstruct SmiteSMD \n    filepath::String    # Path to the directory containing the .mat file\n    filename::String    # Name of the .mat file\n    varname::String     # Variable name in the .mat file (default: \"SMD\")\nend\n\n# Constructor with default variable name\nSmiteSMD(filepath::String, filename::String) = SmiteSMD(filepath, filename, \"SMD\")\n\n# SMLD type compatible with SMITE format\nstruct SmiteSMLD{T,E<:AbstractEmitter} <: SMLD\n    emitters::Vector{E}\n    camera::AbstractCamera\n    n_frames::Int\n    n_datasets::Int\n    metadata::Dict{String,Any}\nend","category":"page"},{"location":"io/#Loading-SMITE-Data","page":"Saving and Loading","title":"Loading SMITE Data","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"SMLMData provides separate functions for loading 2D and 3D data from SMITE format:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"# Load 2D data\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\nsmld_2d = load_smite_2d(smd)\n\n# Load 3D data\nsmld_3d = load_smite_3d(smd)","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"Both functions handle:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"Conversion of coordinates to microns\nCreation of appropriate camera model\nPreservation of metadata","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"Example:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"# Load SMITE data\nsmd = SmiteSMD(\"/data/microscopy\", \"cell1_localizations.mat\")\nsmld = load_smite_2d(smd)\n\n# Inspect metadata\nprintln(\"Loaded $(length(smld.emitters)) emitters\")\nprintln(\"Image size: $(smld.metadata[\"data_size\"])\")\nprintln(\"Pixel size: $(smld.metadata[\"pixel_size\"]) μm\")","category":"page"},{"location":"io/#Saving-SMITE-Data","page":"Saving and Loading","title":"Saving SMITE Data","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"You can save any SMLD object back to SMITE format:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"# Save to SMITE format\nsave_smite(smld, \"output/directory\", \"processed_results.mat\")","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"The save_smite function:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"Converts SMLMData structures to SMITE's structure\nPreserves all metadata fields\nSaves in MATLAB v7.3 format","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"Example workflow:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"# Load data\nsmd = SmiteSMD(\"raw_data\", \"experiment1.mat\")\nsmld = load_smite_2d(smd)\n\n# Process data\nbright = @filter(smld, photons > 1000)\nroi = filter_roi(bright, 10.0:20.0, 10.0:20.0)\n\n# Add analysis info to metadata\nroi.metadata[\"analysis_date\"] = Dates.now()\nroi.metadata[\"selection_criteria\"] = \"photons > 1000, ROI (10-20,10-20)\"\n\n# Save processed data\nsave_smite(roi, \"processed_data\", \"experiment1_processed.mat\")","category":"page"},{"location":"io/#Future-File-Formats","page":"Saving and Loading","title":"Future File Formats","text":"","category":"section"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"SMLMData is designed to be extended with additional file formats. Future versions may include support for:","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"CSV formats\nHDF5\nThunderSTORM\nPicasso","category":"page"},{"location":"io/","page":"Saving and Loading","title":"Saving and Loading","text":"When new formats are added, they will be documented in this section.","category":"page"}]
}
