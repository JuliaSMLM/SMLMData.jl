var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"api/#SMLMData.SMLMData","page":"API Reference","title":"SMLMData.SMLMData","text":"SMLMData\n\nA Julia package for working with Single Molecule Localization Microscopy (SMLM) data.\n\nFeatures\n\nType system for emitters, cameras, and localization data\nPhysical coordinate handling (microns) with camera pixel mappings\nFiltering and ROI selection tools\nSMITE format compatibility\nMemory-efficient data structures\n\nBasic Usage\n\nusing SMLMData\n\n# Create a camera\ncam = IdealCamera(1:512, 1:512, 0.1)  # 512x512 camera with 0.1 micron pixels\n\n# Create some emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n]\n\n# Create SMLD object\nsmld = BasicSMLD(emitters, cam, 1, 1, Dict{String,Any}())\n\n# Filter operations\nroi = filter_roi(smld, 0.0:2.0, 1.0:3.0)\nbright = @filter(smld, photons > 1000)\n\nAPI Overview\n\nFor a comprehensive overview of the API, use the help mode on api:\n\n?api\n\nOr access the complete API documentation programmatically:\n\ndocs = SMLMData.api()\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMData.AbstractCamera","page":"API Reference","title":"SMLMData.AbstractCamera","text":"AbstractCamera\n\nAbstract base type for all camera implementations in single molecule localization microscopy (SMLM).\n\nInterface Requirements\n\nAny concrete subtype of AbstractCamera must provide:\n\nField Requirements:\npixel_edges_x::Vector{<:Real}: Vector of pixel edge positions in x direction\npixel_edges_y::Vector{<:Real}: Vector of pixel edge positions in y direction\nUnits:\nAll edge positions must be in physical units (microns)\nOrigin (0,0) corresponds to the top-left corner of the camera\nFor a camera with N×M pixels, there will be N+1 x-edges and M+1 y-edges\nCoordinate Convention:\nPixel (1,1) is centered at (pixelsizex/2, pixelsizey/2) microns\nEdge positions define the boundaries of pixels in physical space\nFirst edge position corresponds to the left/top edge of the first pixel\nLast edge position corresponds to the right/bottom edge of the last pixel\n\nNotes\n\nEdge positions must be monotonically increasing\nThe number of edges must be one more than the number of pixels in each dimension\nWhile pixels are typically uniform in size, this is not a requirement of the interface\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.AbstractEmitter","page":"API Reference","title":"SMLMData.AbstractEmitter","text":"AbstractEmitter\n\nAbstract supertype for all emitter types in single molecule localization microscopy (SMLM). All spatial coordinates are specified in physical units (microns).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.AbstractSMLD","page":"API Reference","title":"SMLMData.AbstractSMLD","text":"AbstractSMLD\n\nAbstract type representing Single Molecule Localization Data (SMLD).\n\nInterface Requirements\n\nAny concrete subtype of AbstractSMLD must provide:\n\nemitters::Vector{<:AbstractEmitter}: Vector of localized emitters\n\nAdditional fields may include:\n\nCamera information\nAcquisition parameters\nAnalysis metadata\n\nNote: All emitter coordinates must be in physical units (microns).\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.BasicSMLD","page":"API Reference","title":"SMLMData.BasicSMLD","text":"BasicSMLD{T,E<:AbstractEmitter} <: AbstractSMLD\n\nBasic container for single molecule localization data.\n\nFields\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in the acquisition\nmetadata::Dict{String,Any}: Additional dataset information\n\nType Parameters\n\nT: Numeric type for coordinates (typically Float64)\nE: Concrete emitter type\n\nExample\n\n# Create camera\ncam = IdealCamera(1:512, 1:512, 0.1)\n\n# Create some emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 1.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0; frame=1),\n    Emitter2DFit{Float64}(5.0, 5.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0; frame=2)\n]\n\n# Create metadata\nmetadata = Dict{String,Any}(\n    \"exposure_time\" => 0.1,\n    \"timestamp\" => now(),\n    \"sample\" => \"Test Sample\"\n)\n\n# Create SMLD object\ndata = BasicSMLD(emitters, cam, 2, 1, metadata)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.BasicSMLD-Union{Tuple{E}, Tuple{Vector{E}, AbstractCamera, Int64, Int64}, Tuple{Vector{E}, AbstractCamera, Int64, Int64, Dict{String, Any}}} where E<:AbstractEmitter","page":"API Reference","title":"SMLMData.BasicSMLD","text":"BasicSMLD(emitters::Vector{E}, camera::AbstractCamera,\n          n_frames::Int, n_datasets::Int,\n          metadata::Dict{String,Any}=Dict{String,Any}()) where E<:AbstractEmitter\n\nConstruct a BasicSMLD from a vector of emitters and required metadata.\n\nArguments\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in acquisition\nmetadata::Dict{String,Any}=Dict{String,Any}(): Optional additional information\n\nThe numeric type T is inferred from the camera's pixeledgesx type.\n\nExample\n\n# Create with minimal metadata\ndata = BasicSMLD(emitters, camera, 10, 1)\n\n# Create with additional metadata\ndata = BasicSMLD(emitters, camera, 10, 1, Dict(\n    \"exposure_time\" => 0.1,\n    \"timestamp\" => now()\n))\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.Emitter2D","page":"API Reference","title":"SMLMData.Emitter2D","text":"Emitter2D{T} <: AbstractEmitter\n\nRepresents a 2D emitter for SMLM simulations with position and brightness.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nphotons::T: number of photons emitted by the fluorophore\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter2DFit","page":"API Reference","title":"SMLMData.Emitter2DFit","text":"Emitter2DFit{T} <: AbstractEmitter\n\nRepresents fitted 2D localization results with uncertainties and temporal/tracking information.\n\nFields\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_xy::T: covariance between x and y uncertainties (microns², 0 = axis-aligned)\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background in photons/pixel\nframe::Int: frame number in acquisition sequence\ndataset::Int: identifier for specific acquisition/dataset\ntrack_id::Int: identifier for linking localizations across frames (0 = unlinked)\nid::Int: unique identifier within dataset\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter2DFit-Union{Tuple{T}, NTuple{8, T}} where T","page":"API Reference","title":"SMLMData.Emitter2DFit","text":"Emitter2DFit{T}(x, y, photons, bg, σ_x, σ_y, σ_photons, σ_bg;\n                σ_xy=zero(T), frame=1, dataset=1, track_id=0, id=0) where T\n\nConvenience constructor for 2D localization fit results with optional identification parameters.\n\nArguments\n\nRequired\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background level\n\nOptional Keywords\n\nσ_xy::T=0: covariance between x and y uncertainties (microns², 0 = axis-aligned)\nframe::Int=1: frame number in acquisition sequence\ndataset::Int=1: identifier for specific acquisition/dataset\ntrack_id::Int=0: identifier for linking localizations across frames\nid::Int=0: unique identifier within dataset\n\nExample\n\n# Create emitter with just required parameters\nemitter = Emitter2DFit{Float64}(\n    1.0, 2.0,        # x, y\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01,      # σ_x, σ_y\n    50.0, 2.0        # σ_photons, σ_bg\n)\n\n# Create emitter with covariance for rotated uncertainty ellipse\nemitter = Emitter2DFit{Float64}(\n    1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0;\n    σ_xy=0.005, frame=5, dataset=2\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.Emitter3D","page":"API Reference","title":"SMLMData.Emitter3D","text":"Emitter3D{T} <: AbstractEmitter\n\nRepresents a 3D emitter for SMLM simulations with position and brightness.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nz::T: z-coordinate in microns (axial position)\nphotons::T: number of photons emitted by the fluorophore\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter3DFit","page":"API Reference","title":"SMLMData.Emitter3DFit","text":"Emitter3DFit{T} <: AbstractEmitter\n\nRepresents fitted 3D localization results with uncertainties and temporal/tracking information.\n\nFields\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nz::T: fitted z-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_z::T: uncertainty in z position in microns\nσ_xy::T: covariance between x and y (microns², 0 = uncorrelated)\nσ_xz::T: covariance between x and z (microns², 0 = uncorrelated)\nσ_yz::T: covariance between y and z (microns², 0 = uncorrelated)\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background in photons/pixel\nframe::Int: frame number in acquisition sequence\ndataset::Int: identifier for specific acquisition/dataset\ntrack_id::Int: identifier for linking localizations across frames (0 = unlinked)\nid::Int: unique identifier within dataset\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.Emitter3DFit-Union{Tuple{T}, NTuple{10, T}} where T","page":"API Reference","title":"SMLMData.Emitter3DFit","text":"Emitter3DFit{T}(x, y, z, photons, bg, σ_x, σ_y, σ_z, σ_photons, σ_bg;\n                σ_xy=zero(T), σ_xz=zero(T), σ_yz=zero(T),\n                frame=1, dataset=1, track_id=0, id=0) where T\n\nConvenience constructor for 3D localization fit results with optional identification parameters.\n\nArguments\n\nRequired\n\nx::T: fitted x-coordinate in microns\ny::T: fitted y-coordinate in microns\nz::T: fitted z-coordinate in microns\nphotons::T: fitted number of photons\nbg::T: fitted background in photons/pixel\nσ_x::T: uncertainty in x position in microns\nσ_y::T: uncertainty in y position in microns\nσ_z::T: uncertainty in z position in microns\nσ_photons::T: uncertainty in photon count\nσ_bg::T: uncertainty in background level\n\nOptional Keywords\n\nσ_xy::T=0: covariance between x and y (microns², 0 = uncorrelated)\nσ_xz::T=0: covariance between x and z (microns², 0 = uncorrelated)\nσ_yz::T=0: covariance between y and z (microns², 0 = uncorrelated)\nframe::Int=1: frame number in acquisition sequence\ndataset::Int=1: identifier for specific acquisition/dataset\ntrack_id::Int=0: identifier for linking localizations across frames\nid::Int=0: unique identifier within dataset\n\nExample\n\n# Create emitter with just required parameters\nemitter = Emitter3DFit{Float64}(\n    1.0, 2.0, -0.5,  # x, y, z\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01, 0.02,# σ_x, σ_y, σ_z\n    50.0, 2.0        # σ_photons, σ_bg\n)\n\n# Create emitter with full 3D covariance\nemitter = Emitter3DFit{Float64}(\n    1.0, 2.0, -0.5, 1000.0, 10.0, 0.01, 0.01, 0.02, 50.0, 2.0;\n    σ_xy=0.005, σ_xz=0.002, σ_yz=0.003, frame=5, track_id=1\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera{T} <: AbstractCamera\n\nRepresents an ideal camera with regularly spaced pixels defined by their edges in physical units (microns).\n\nFields\n\npixel_edges_x::Vector{T}: Physical positions of pixel edges in x direction (microns)\npixel_edges_y::Vector{T}: Physical positions of pixel edges in y direction (microns)\n\nThe edges are computed from pixel centers, where pixel (1,1) is centered at  (pixelsizex/2, pixelsizey/2) in physical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(pixel_centers_x::AbstractUnitRange, pixel_centers_y::AbstractUnitRange, \n            pixel_size::Tuple{T, T}) where T<:Real\n\nConstruct an IdealCamera with rectangular pixels given pixel center positions and x,y pixel sizes.\n\nArguments\n\npixel_centers_x::AbstractUnitRange: Range of pixel center indices in x (typically 1:N)\npixel_centers_y::AbstractUnitRange: Range of pixel center indices in y (typically 1:M)\npixel_size::Tuple{T, T}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of the pixel sizes\n\nType Parameters\n\nT: Numeric type for all spatial measurements (e.g., Float64, Float32)\n\nExample\n\n# Create a 512x256 camera with rectangular pixels (0.1 x 0.15 microns)\ncam = IdealCamera(1:512, 1:256, (0.1, 0.15))\n\n# Create with Float32 precision\ncam32 = IdealCamera(1:512, 1:256, (0.1f0, 0.15f0))\n\nNote: Pixel (1,1) is centered at (pixelsize[1]/2, pixelsize[2]/2) in physical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, T}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(pixel_centers_x::AbstractUnitRange, pixel_centers_y::AbstractUnitRange, pixel_size::T) where T<:Real\n\nConstruct an IdealCamera with square pixels given pixel center positions and a scalar pixel size.\n\nArguments\n\npixel_centers_x::AbstractUnitRange: Range of pixel center indices in x (typically 1:N)\npixel_centers_y::AbstractUnitRange: Range of pixel center indices in y (typically 1:M)\npixel_size::Real: Size of pixels in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of pixel_size\n\nType Parameters\n\nT: Numeric type for all spatial measurements (e.g., Float64, Float32)\n\nExample\n\n# Create a 512x512 camera with 0.1 micron square pixels\ncam = IdealCamera(1:512, 1:512, 0.1)\n\n# Create with Float32 precision\ncam32 = IdealCamera(1:512, 1:512, 0.1f0)\n\nNote: Pixel (1,1) is centered at (pixelsize/2, pixelsize/2) in physical coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{Integer, Integer, Tuple{T, T}}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(n_pixels_x::Integer, n_pixels_y::Integer, pixel_size::Tuple{T, T}) where T<:Real\n\nConstruct an IdealCamera with rectangular pixels directly from the number of pixels and x,y pixel sizes.\n\nArguments\n\nn_pixels_x::Integer: Number of pixels in x dimension\nn_pixels_y::Integer: Number of pixels in y dimension\npixel_size::Tuple{T, T}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of the pixel sizes\n\nExample\n\n# Create a 512x256 camera with rectangular pixels (0.1 x 0.15 microns)\ncam = IdealCamera(512, 256, (0.1, 0.15))\n\n# Create with Float32 precision\ncam32 = IdealCamera(512, 256, (0.1f0, 0.15f0))\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.IdealCamera-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:Real","page":"API Reference","title":"SMLMData.IdealCamera","text":"IdealCamera(n_pixels_x::Integer, n_pixels_y::Integer, pixel_size::T) where T<:Real\n\nConstruct an IdealCamera with square pixels directly from the number of pixels and pixel size.\n\nArguments\n\nn_pixels_x::Integer: Number of pixels in x dimension\nn_pixels_y::Integer: Number of pixels in y dimension\npixel_size::Real: Size of pixels in microns\n\nReturns\n\nIdealCamera{T} where T matches the type of pixel_size\n\nExample\n\n# Create a 512x512 camera with 0.1 micron square pixels\ncam = IdealCamera(512, 512, 0.1)\n\n# Create with Float32 precision\ncam32 = IdealCamera(512, 512, 0.1f0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.ROIBatch","page":"API Reference","title":"SMLMData.ROIBatch","text":"ROIBatch{T,N,A,C}\n\nBatch of regions of interest for efficient parallel processing with camera context.\n\nThis type serves as the standard interface for ROI-based processing across the JuliaSMLM ecosystem. ROIs are extracted by SMLMBoxer and consumed by fitting packages like GaussMLE.\n\nType Parameters\n\nT: Element type of ROI data (typically Float32 or Float64)\nN: Dimension of data array (always 3 for ROI batches)\nA: Array type (e.g., Array, CuArray for GPU)\nC: Camera type (AbstractCamera subtype)\n\nFields\n\ndata::A - ROI image stack (roisize × roisize × n_rois)\nx_corners::Vector{Int32} - X (column) coordinates of ROI corners in camera coordinates\ny_corners::Vector{Int32} - Y (row) coordinates of ROI corners in camera coordinates\nframe_indices::Vector{Int32} - Frame number for each ROI (1-indexed)\ncamera::C - Camera object (IdealCamera or SCMOSCamera) representing full image\nroi_size::Int - Size of each ROI in pixels (assumed square)\n\nCoordinate System\n\nCamera coordinates: 1-indexed, (1,1) = top-left of full image\nROI corners: (x, y) = (col, row) position in camera coordinates\nROI data: Local coordinates, (1,1) = top-left within ROI\nFrame indices: 1-indexed, matching camera frame numbering\n\nConstructors\n\nFrom arrays (main constructor)\n\nROIBatch(data::AbstractArray{T,3}, x_corners::Vector{Int32}, y_corners::Vector{Int32},\n         frame_indices::Vector{Int32}, camera::AbstractCamera)\n\nFrom separate x/y corner vectors\n\nROIBatch(data::AbstractArray{T,3}, x_corners::Vector, y_corners::Vector,\n         frame_indices::Vector, camera::AbstractCamera)\n\nFrom vector of SingleROI\n\nROIBatch(rois::Vector{SingleROI{T}}, camera::AbstractCamera)\n\nValidation\n\nROIs must be square (data dimensions 1 == dimension 2)\nxcorners must have length nrois\nycorners must have length nrois\nFrame indices must have length n_rois\nAll arrays must have consistent n_rois\n\nIndexing and Iteration\n\nbatch = ROIBatch(data, x_corners, y_corners, frames, camera)\n\n# Get single ROI\nroi = batch[5]  # Returns SingleROI{T}\n\n# Iterate over all ROIs\nfor roi in batch\n    process(roi.data, roi.corner, roi.frame_idx)\nend\n\n# Length\nn = length(batch)  # Number of ROIs\n\nGPU Support\n\nSupports GPU transfer via Adapt.jl (KernelAbstractions.jl):\n\nusing CUDA\nbatch_gpu = adapt(CuArray, batch)  # Transfer data to GPU\n# Camera stays on host (contains metadata)\n\nExample\n\nusing SMLMData\nusing StaticArrays\n\n# Create camera\ncamera = IdealCamera(512, 512, 0.1)  # 512×512 pixels, 0.1μm/pixel\n\n# Create ROI batch (e.g., from SMLMBoxer.getboxes)\nn_rois = 100\nroi_size = 11\ndata = rand(Float32, roi_size, roi_size, n_rois)\nx_corners = rand(Int32(1):Int32(500), n_rois)\ny_corners = rand(Int32(1):Int32(500), n_rois)\nframes = rand(Int32(1):Int32(10), n_rois)\n\nbatch = ROIBatch(data, x_corners, y_corners, frames, camera)\n\n# Access\nprintln(\"Batch contains $(length(batch)) ROIs\")\nfirst_roi = batch[1]\nprintln(\"First ROI at position: $(first_roi.corner)\")\n\nSee Also\n\nSingleROI - Individual ROI type\nIdealCamera, SCMOSCamera - Camera types\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.ROIBatch-Union{Tuple{C}, Tuple{T}, Tuple{AbstractArray{T, 3}, Vector, Vector, Vector, C}} where {T, C<:AbstractCamera}","page":"API Reference","title":"SMLMData.ROIBatch","text":"ROIBatch(data, x_corners, y_corners, frame_indices, camera)\n\nConstruct ROIBatch from separate x and y corner vectors.\n\nArguments\n\ndata::AbstractArray{T,3} - ROI stack (roisize × roisize × n_rois)\nx_corners::Vector - X (column) coordinates of ROI corners\ny_corners::Vector - Y (row) coordinates of ROI corners\nframe_indices::Vector - Frame number for each ROI\ncamera::AbstractCamera - Camera object for full image\n\nExample\n\nbatch = ROIBatch(data, x_corners, y_corners, frames, camera)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.ROIBatch-Union{Tuple{C}, Tuple{T}, Tuple{Array{SingleROI{T}, 1}, C}} where {T, C<:AbstractCamera}","page":"API Reference","title":"SMLMData.ROIBatch","text":"ROIBatch(rois::Vector{SingleROI{T}}, camera)\n\nConstruct ROIBatch from vector of SingleROI objects.\n\nArguments\n\nrois::Vector{SingleROI{T}} - Vector of individual ROIs\ncamera::AbstractCamera - Camera object for full image\n\nReturns\n\nROIBatch{T,3,Array{T,3},typeof(camera)}\n\nExample\n\nrois = [SingleROI(rand(Float32, 11, 11), SVector{2,Int32}(i*10, i*10), Int32(i))\n        for i in 1:100]\nbatch = ROIBatch(rois, camera)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SCMOSCamera","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera{T<:Real} <: AbstractCamera\n\nsCMOS camera with pixel-dependent calibration parameters matching spec sheets.\n\nFields\n\npixel_edges_x::Vector{T}: Physical pixel edges in x (μm)\npixel_edges_y::Vector{T}: Physical pixel edges in y (μm)\noffset::Union{T, Matrix{T}}: Dark level (ADU)\ngain::Union{T, Matrix{T}}: Conversion gain (e⁻/ADU)\nreadnoise::Union{T, Matrix{T}}: Read noise (e⁻ rms)\nqe::Union{T, Matrix{T}}: Quantum efficiency (0-1)\n\nUnits\n\nCalibration parameters follow camera specification sheet conventions:\n\noffset: ADU (analog-to-digital units)\nTypical values: 100-500 ADU\nDark level with no illumination\ngain: e⁻/ADU (electrons per ADU)\nTypical values: 0.1-2.0 e⁻/ADU depending on readout mode\nExample: ORCA-Flash4.0: 0.46 e⁻/ADU (12-bit), 0.11 e⁻/ADU (16-bit)\nreadnoise: e⁻ rms (electrons, root-mean-square)\nTypical values: 0.3-5.0 e⁻ rms\nExample: ORCA-Flash4.0 V3: 1.6 e⁻ rms\nExample: ORCA-Quest qCMOS: 0.27 e⁻ rms\nqe: dimensionless (0 to 1)\nTypical values: 0.5-0.95 at peak wavelength\nExample: ORCA-Flash4.0 V2: 0.72 at 550nm\nExample: ORCA-Fusion BT: 0.95 (back-thinned)\n\nPhysical Signal Chain\n\nPhotons → Electrons → ADU:\n\nIncident photons (N)\n  ↓ [× QE]\nPhotoelectrons (N × QE)\n  ↓ [+ readnoise (Gaussian)]\nSignal electrons (N × QE + ε), where ε ~ N(0, readnoise²)\n  ↓ [÷ gain, + offset]\nADU readout = (N × QE + ε)/gain + offset\n\nScalar vs Matrix Parameters\n\nEach calibration parameter can be:\n\nScalar (T): Uniform across sensor (approximation or post-calibration)\nMatrix (Matrix{T}): Per-pixel calibration map (size must match pixel grid)\n\nUse matrices for:\n\nPrecision SMLM (2-5% variations can affect results)\nQuantitative imaging\nArtifact correction\n\nUse scalars for:\n\nQuick analysis\nPost-calibrated data\nUniform approximation\n\nConstructors\n\n# Minimal - most common case (requires readnoise, others default to 0, 1, 1)\ncam = SCMOSCamera(512, 512, 0.1, 1.6)\n\n# With additional parameters\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                  offset=100.0, gain=0.46, qe=0.72)\n\n# Custom edges (advanced)\ncam = SCMOSCamera(custom_edges_x, custom_edges_y,\n                  readnoise=noise_map, gain=gain_map)\n\nExamples\n\n# Example 1: From spec sheet (ORCA-Flash4.0 V3, 12-bit mode)\ncam = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                 # From spec: 1.6 e⁻ rms readnoise\n    offset = 100.0,      # Typical offset\n    gain = 0.46,         # From spec: 0.46 e⁻/ADU\n    qe = 0.72            # 72% QE at 550nm\n)\n\n# Example 2: With calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\n\ncam = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,\n    gain = gain_map,\n    qe = qe_map\n)\n\n# Example 3: Minimal (variance-only approximation)\n# Common when you only have noise map, assume ideal otherwise\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map)\n\n# Example 4: Ultra-low noise camera (ORCA-Quest)\ncam = SCMOSCamera(\n    2304, 4096, 0.0044,  # 4.4μm pixels\n    0.27,                 # Incredible 0.27 e⁻ rms!\n    offset = 100.0,\n    gain = 0.5,\n    qe = 0.85\n)\n\n# Example 5: Rectangular pixels\ncam = SCMOSCamera(512, 256, (0.1, 0.15), 1.8)\n\n# Example 6: Mixed scalar/matrix parameters\ncam = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5,                     # Uniform gain\n    qe = qe_map                     # Per-pixel QE\n)\n\nSee Also\n\nIdealCamera for Poisson-only noise (readnoise=0)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SCMOSCamera-Union{Tuple{T}, Tuple{Integer, Integer, Union{Tuple{T, T}, T}, Union{Matrix{T}, T}}} where T<:Real","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera(nx, ny, pixel_size, readnoise; offset=0, gain=1, qe=1)\n\nConstruct sCMOS camera from pixel dimensions and calibration parameters.\n\nArguments\n\nnx::Integer: Number of pixels in x\nny::Integer: Number of pixels in y\npixel_size::Union{T, Tuple{T,T}}: Pixel size in μm (scalar or (xsize, ysize))\nreadnoise::Union{T, Matrix{T}}: Read noise in e⁻ rms (required)\n\nKeywords\n\noffset::Union{T, Matrix{T}} = 0: Dark level in ADU\ngain::Union{T, Matrix{T}} = 1: Conversion gain in e⁻/ADU\nqe::Union{T, Matrix{T}} = 1: Quantum efficiency (0-1)\n\nEach parameter can be scalar (uniform) or Matrix{T} with size (ny, nx) following Julia's [row, col] convention.\n\nExamples\n\n# Minimal: just readnoise (assumes calibrated data: offset=0, gain=1, qe=1)\ncam = SCMOSCamera(512, 512, 0.1, 1.6)\n\n# From spec sheet (ORCA-Flash4.0 V3)\ncam = SCMOSCamera(2048, 2048, 0.065, 1.6, offset=100.0, gain=0.46, qe=0.72)\n\n# With calibration maps\ncam = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                  offset=offset_map, gain=gain_map, qe=qe_map)\n\n# Rectangular pixels\ncam = SCMOSCamera(512, 256, (0.1, 0.15), 1.8)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SCMOSCamera-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Real","page":"API Reference","title":"SMLMData.SCMOSCamera","text":"SCMOSCamera(pixel_edges_x, pixel_edges_y; offset=0, gain=1, readnoise, qe=1)\n\nConstruct sCMOS camera with custom pixel edge positions.\n\nArguments\n\npixel_edges_x::Vector{T}: Pixel edge positions in x (μm), length nx+1\npixel_edges_y::Vector{T}: Pixel edge positions in y (μm), length ny+1\n\nKeywords\n\nreadnoise::Union{T, Matrix{T}}: Read noise in e⁻ rms (required)\noffset::Union{T, Matrix{T}} = 0: Dark level in ADU\ngain::Union{T, Matrix{T}} = 1: Conversion gain in e⁻/ADU\nqe::Union{T, Matrix{T}} = 1: Quantum efficiency (0-1)\n\nMatrix parameters must have size (ny, nx) following Julia's [row, col] convention, where nx = length(pixeledgesx) - 1 and ny = length(pixeledgesy) - 1.\n\nExample\n\n# Custom non-uniform pixel grid\nedges_x = [0.0, 0.1, 0.21, 0.33, 0.46]  # Non-uniform spacing\nedges_y = [0.0, 0.1, 0.2, 0.3]\ncam = SCMOSCamera(edges_x, edges_y, readnoise=1.5, gain=0.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.SMLD","page":"API Reference","title":"SMLMData.SMLD","text":"SMLD\n\nDeprecated alias for AbstractSMLD. Use AbstractSMLD instead. This alias is provided for backward compatibility and will be removed in v1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SingleROI","page":"API Reference","title":"SMLMData.SingleROI","text":"SingleROI{T}\n\nSingle region of interest (ROI) with location and frame context.\n\nFields\n\ndata::Matrix{T} - ROI image data (roisize × roisize pixels)\ncorner::SVector{2,Int32} - ROI corner position (x, y) = (col, row) in camera pixels (1-indexed)\nframe_idx::Int32 - Frame number in image stack (1-indexed)\n\nCoordinate System\n\nCamera coordinates: 1-indexed, (1,1) is top-left pixel of full image\nCorner: (x, y) = (col, row) position where top-left of ROI starts\nROI data: (1,1) is top-left pixel within the ROI itself\n\nExample\n\n# Create single ROI\nroi_data = rand(Float32, 11, 11)  # 11×11 pixel ROI\nroi = SingleROI(roi_data, SVector{2,Int32}(100, 200), Int32(5))\n\n# Access fields\nprintln(\"ROI at camera position: \", roi.corner)  # (100, 200) = (col, row)\nprintln(\"From frame: \", roi.frame_idx)  # Frame 5\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SmiteSMD","page":"API Reference","title":"SMLMData.SmiteSMD","text":"SmiteSMD\n\nHelper structure for loading Smite SMD .mat files.\n\nFields\n\nfilepath::String: Path to the directory containing the .mat file\nfilename::String: Name of the .mat file\nvarname::String: Variable name in the .mat file (default: \"SMD\")\n\nExample\n\n# Load from default \"SMD\" variable\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\n\n# Load from custom variable name\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\", \"CustomSMD\")\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMData.SmiteSMLD","page":"API Reference","title":"SMLMData.SmiteSMLD","text":"SmiteSMLD{T,E<:AbstractEmitter} <: AbstractSMLD\n\nSMLD type compatible with the Smite SMD (Single Molecule Data) format.\n\nFields\n\nemitters::Vector{E}: Vector of localized emitters\ncamera::AbstractCamera: Camera used for acquisition\nn_frames::Int: Total number of frames in acquisition\nn_datasets::Int: Number of datasets in the acquisition\nmetadata::Dict{String,Any}: Additional dataset information\n\nType Parameters\n\nT: Numeric type for coordinates (typically Float64)\nE: Concrete emitter type (typically Emitter2DFit or Emitter3DFit)\n\n\n\n\n\n","category":"type"},{"location":"api/#Adapt.adapt_structure-Tuple{Any, ROIBatch}","page":"API Reference","title":"Adapt.adapt_structure","text":"Adapt.adapt_structure(to, batch::ROIBatch)\n\nAdapt ROIBatch for GPU execution via KernelAbstractions.jl/CUDA.jl.\n\nTransfers data, xcorners, ycorners, and frame_indices to the target device. Camera remains on the host (contains metadata and variance maps).\n\nExample\n\nusing CUDA\nbatch_gpu = adapt(CuArray, batch)\n# Process on GPU...\nbatch_cpu = adapt(Array, batch_gpu)  # Transfer back\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{ROIBatch, Int64}","page":"API Reference","title":"Base.getindex","text":"getindex(batch::ROIBatch, i::Int) -> SingleROI\n\nGet the i-th ROI from the batch.\n\nReturns a SingleROI containing the data, corner position, and frame index.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate","page":"API Reference","title":"Base.iterate","text":"iterate(batch::ROIBatch, [state]) -> Union{Nothing, Tuple{SingleROI, Int}}\n\nIterate over ROIs in the batch.\n\nExample\n\nfor roi in batch\n    println(\"Processing ROI at \", roi.corner)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.iterate-Tuple{AbstractSMLD}","page":"API Reference","title":"Base.iterate","text":"Base.iterate(smld::AbstractSMLD)\nBase.iterate(smld::AbstractSMLD, state)\n\nEnable iteration over emitters in an SMLD object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{AbstractSMLD}","page":"API Reference","title":"Base.length","text":"Base.length(smld::AbstractSMLD)\n\nReturn the number of emitters in the SMLD object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{ROIBatch}","page":"API Reference","title":"Base.length","text":"length(batch::ROIBatch) -> Int\n\nNumber of ROIs in the batch.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{C}, Tuple{A}, Tuple{N}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, ROIBatch{T, N, A, C}}} where {T, N, A, C}","page":"API Reference","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", batch::ROIBatch)\n\nDetailed display of ROIBatch.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, SingleROI{T}}} where T","page":"API Reference","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", roi::SingleROI)\n\nDetailed display of SingleROI.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{IO, ROIBatch{T, N, A} where {N, A<:AbstractArray{T, N}}}} where T","page":"API Reference","title":"Base.show","text":"show(io::IO, batch::ROIBatch)\n\nCompact display of ROIBatch.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{IO, SingleROI{T}}} where T","page":"API Reference","title":"Base.show","text":"show(io::IO, roi::SingleROI)\n\nCompact display of SingleROI.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{ROIBatch}","page":"API Reference","title":"Base.size","text":"size(batch::ROIBatch) -> Tuple{Int}\n\nSize of the batch (returns tuple for consistency with iteration protocol).\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.api_overview-Tuple{}","page":"API Reference","title":"SMLMData.api_overview","text":"SMLMData.jl API Overview\n\nThis guide provides a structured overview of the SMLMData.jl package designed for Single Molecule Localization Microscopy (SMLM) data handling in Julia.\n\nWhy This Overview Exists\n\nFor Humans\n\nProvides a concise reference without diving into full documentation\nOffers quick-start examples for common use cases\nShows relevant patterns more clearly than individual docstrings\nCreates an at-a-glance understanding of package capabilities\n\nFor AI Assistants\n\nEnables better code generation with correct API patterns\nProvides structured context about type hierarchies and relationships\nOffers consistent examples to learn from when generating code\nHelps avoid common pitfalls or misunderstandings about the API\n\nEcosystem Role\n\nSMLMData is the core types package for the JuliaSMLM ecosystem. Other packages depend on SMLMData and re-export its types, so you rarely need to import SMLMData directly:\n\nusing GaussMLE      # Re-exports ROIBatch, camera types, etc.\nusing SMLMAnalysis  # Re-exports all SMLMData types for analysis workflows\n\nDirect using SMLMData is primarily for package developers, standalone data manipulation, or learning the type system.\n\nKey Concepts\n\nEmitters: Individual fluorophore localizations (2D or 3D)\nCamera: Defines pixel geometry and coordinate system\nAbstractSMLD: Container holding emitters and camera information\nCoordinates: All spatial coordinates are in microns\nCoordinate System:\nPhysical space: (0,0) at top-left corner of camera\nPixel space: (1,1) at center of top-left pixel\n\nType Hierarchy\n\nAbstractEmitter                   # Base for all emitter types\n├── Emitter2D{T}                  # Basic 2D emitters\n├── Emitter3D{T}                  # Basic 3D emitters\n├── Emitter2DFit{T}               # 2D emitters with fit results\n└── Emitter3DFit{T}               # 3D emitters with fit results\n\nAbstractCamera                    # Base for all camera types\n├── IdealCamera{T}                # Camera with regular pixel grid (Poisson noise only)\n└── SCMOSCamera{T}                # sCMOS camera with pixel-dependent calibration\n\nROI Batch Types                   # For batched ROI processing\n├── SingleROI{T}                  # Single ROI with location context\n└── ROIBatch{T,N,A,C}             # Batch of ROIs for parallel processing\n\nAbstractSMLD                      # Base for data containers\n├── BasicSMLD{T,E}                # General-purpose container\n└── SmiteSMLD{T,E}                # SMITE-compatible container\n\nEssential Types\n\nEmitter Types\n\n# Basic 2D emitter\nmutable struct Emitter2D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\n# Basic 3D emitter\nmutable struct Emitter3D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    z::T           # z-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\n# 2D emitter with fit results\nmutable struct Emitter2DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_xy::T        # covariance between x and y (microns², 0 = axis-aligned)\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\n# 3D emitter with fit results\nmutable struct Emitter3DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    z::T           # fitted z-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_z::T         # uncertainty in z position in microns\n    σ_xy::T        # covariance between x and y (microns², 0 = uncorrelated)\n    σ_xz::T        # covariance between x and z (microns², 0 = uncorrelated)\n    σ_yz::T        # covariance between y and z (microns², 0 = uncorrelated)\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\nEmitter Constructor Examples\n\n# Basic 2D emitter\nemitter_2d = Emitter2D{Float64}(\n    1.5,      # x-coordinate in microns\n    2.3,      # y-coordinate in microns  \n    1000.0    # number of photons emitted\n)\n\n# Basic 3D emitter\nemitter_3d = Emitter3D{Float64}(\n    1.5,      # x-coordinate in microns\n    2.3,      # y-coordinate in microns\n    -0.5,     # z-coordinate in microns (negative = below focal plane)\n    1000.0    # number of photons emitted\n)\n\n# 2D emitter with fit results using convenience constructor\nemitter_2d_fit = Emitter2DFit{Float64}(\n    1.5, 2.3,        # x, y coordinates in microns\n    1000.0, 10.0,    # photons detected, background photons/pixel\n    0.01, 0.01,      # σ_x, σ_y: position uncertainties in microns\n    50.0, 2.0;       # σ_photons, σ_bg: photon count uncertainties\n    σ_xy=0.005,      # covariance (optional, default=0 for axis-aligned uncertainty)\n    frame=5,         # frame number in acquisition (1-based, default=1)\n    dataset=1,       # dataset identifier for multi-acquisition experiments\n    track_id=2,      # tracking ID for linked localizations (default=0 = unlinked)\n    id=42            # unique identifier within this dataset (default=0)\n)\n\nCamera Types\n\n# Ideal camera with uniform pixel grid (Poisson noise only)\nstruct IdealCamera{T} <: AbstractCamera\n    pixel_edges_x::Vector{T}  # pixel edges in x\n    pixel_edges_y::Vector{T}  # pixel edges in y\nend\n\n# sCMOS camera with pixel-dependent calibration parameters\nstruct SCMOSCamera{T} <: AbstractCamera\n    pixel_edges_x::Vector{T}      # pixel edges in x\n    pixel_edges_y::Vector{T}      # pixel edges in y\n    offset::Union{T, Matrix{T}}   # dark level (ADU)\n    gain::Union{T, Matrix{T}}     # conversion gain (e⁻/ADU)\n    readnoise::Union{T, Matrix{T}}  # read noise (e⁻ rms)\n    qe::Union{T, Matrix{T}}       # quantum efficiency (0-1)\nend\n\nCamera Constructor Examples\n\n# IdealCamera: Create a camera with 512x512 pixels, each 100nm (0.1μm) in size\n# Convenience constructor (most common)\ncam = IdealCamera(512, 512, 0.1)\n\n# Explicit constructor using pixel center ranges\ncam_explicit = IdealCamera(1:512, 1:512, 0.1)\n\n# For non-square pixels, specify different x and y sizes\ncam_rect = IdealCamera(512, 512, (0.1, 0.12))\n\n# SCMOSCamera: Create with readnoise specification (matching spec sheets)\n# Minimal (uniform readnoise, assumes offset=0, gain=1, qe=1)\ncam_scmos = SCMOSCamera(512, 512, 0.1, 1.6)  # 1.6 e⁻ rms readnoise\n\n# From camera spec sheet (e.g., ORCA-Flash4.0 V3)\ncam_flash = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                # 1.6 e⁻ rms readnoise from spec\n    offset = 100.0,     # typical dark level\n    gain = 0.46,        # 0.46 e⁻/ADU from spec\n    qe = 0.72           # 72% QE at 550nm\n)\n\n# With per-pixel calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\ncam_calibrated = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                              gain=gain_map, qe=qe_map)\n\n# Mixed scalar and matrix parameters\ncam_mixed = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5,                     # Uniform gain\n    qe = qe_map                     # Per-pixel QE\n)\n\nROI Batch Types\n\nROI batch types provide efficient storage and processing of image regions across the JuliaSMLM ecosystem.\n\n# Single ROI with location context\nstruct SingleROI{T}\n    data::Matrix{T}              # ROI image data (roi_size × roi_size)\n    corner::SVector{2,Int32}     # (x, y) = (col, row) corner position (1-indexed)\n    frame_idx::Int32             # Frame number (1-indexed)\nend\n\n# Batch of ROIs for parallel processing\nstruct ROIBatch{T,N,A<:AbstractArray{T,N},C<:AbstractCamera}\n    data::A                      # ROI stack (roi_size × roi_size × n_rois)\n    x_corners::Vector{Int32}     # X (column) coordinates of ROI corners\n    y_corners::Vector{Int32}     # Y (row) coordinates of ROI corners\n    frame_indices::Vector{Int32} # Frame number for each ROI\n    camera::C                    # Camera object (IdealCamera or SCMOSCamera)\n    roi_size::Int                # Size of each ROI (square)\nend\n\nROI Batch Constructor Examples\n\n# From separate x/y corner vectors (main constructor)\ncamera = IdealCamera(512, 512, 0.1)\ndata = rand(Float32, 11, 11, 100)  # 100 ROIs of 11×11 pixels\nx_corners = rand(Int32(1):Int32(500), 100)\ny_corners = rand(Int32(1):Int32(500), 100)\nframe_indices = rand(Int32(1):Int32(50), 100)\nbatch = ROIBatch(data, x_corners, y_corners, frame_indices, camera)\n\n# From vector of SingleROI\nrois = [SingleROI(rand(Float32, 11, 11), SVector{2,Int32}(i*10, i*10), Int32(i))\n        for i in 1:100]\nbatch = ROIBatch(rois, camera)\n\n# Indexing and iteration\nroi = batch[5]              # Get single ROI\nfor roi in batch\n    process(roi.data)       # Iterate over all ROIs\nend\n\n# GPU adaptation (via Adapt.jl)\nusing CUDA\nbatch_gpu = adapt(CuArray, batch)  # Transfer to GPU\n\nCoordinate System:\n\nCamera coordinates: 1-indexed, (1,1) = top-left of full image\nROI corners: (x, y) = (col, row) position in camera coordinates\nROI data: Local coordinates, (1,1) = top-left within ROI\nFrame indices: 1-indexed, matching camera frame numbering\n\nTypical Workflow:\n\nSMLMBoxer extracts ROIs → ROIBatch\nGaussMLE fits ROIs → LocalizationResult\nConvert to BasicSMLD for analysis\n\nSMLD Container Types\n\n# Basic SMLD container\nstruct BasicSMLD{T,E<:AbstractEmitter} <: AbstractSMLD\n    emitters::Vector{E}        # Vector of emitters\n    camera::AbstractCamera     # Camera information\n    n_frames::Int              # Total number of frames\n    n_datasets::Int            # Number of datasets\n    metadata::Dict{String,Any} # Additional information\nend\n\n# SMITE format compatible container\nstruct SmiteSMLD{T,E<:AbstractEmitter} <: AbstractSMLD\n    emitters::Vector{E}        # Vector of emitters\n    camera::AbstractCamera     # Camera information\n    n_frames::Int              # Total number of frames\n    n_datasets::Int            # Number of datasets\n    metadata::Dict{String,Any} # Additional information\nend\n\nSMLD Constructor Examples\n\n# Create a vector of emitters\nemitters = [\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n]\n\n# Create a BasicSMLD\nsmld = BasicSMLD(emitters, camera, 1, 1, Dict{String,Any}())\n\n# Add metadata\nsmld_with_metadata = BasicSMLD(\n    emitters, \n    camera, \n    10,  # number of frames\n    1,   # number of datasets\n    Dict{String,Any}(\n        \"exposure_time\" => 0.1,\n        \"sample\" => \"Test Sample\"\n    )\n)\n\nCore Functions\n\nAccessing the API Overview\n\n# Get this API overview as a string programmatically\noverview_text = api_overview()\n\nCoordinate Conversions\n\n# Convert from pixel to physical coordinates (microns)\nx_physical, y_physical = pixel_to_physical(px, py, pixel_size)\n\n# Convert from physical to pixel coordinates\npx, py = physical_to_pixel(x, y, pixel_size)\n\n# Convert from physical to pixel indices (integers)\npx_idx, py_idx = physical_to_pixel_index(x, y, pixel_size)\n\n# Get physical coordinates of all pixel centers\ncenters_x, centers_y = get_pixel_centers(camera)\n\nFiltering Operations\n\n# Filter by emitter properties using @filter macro\nbright = @filter(smld, photons > 1000)                     # Select bright emitters\nprecise = @filter(smld, σ_x < 0.02 && σ_y < 0.02)         # Select precisely localized emitters\ncombined = @filter(smld, photons > 1000 && σ_x < 0.02)     # Combine multiple criteria\n\n# The @filter macro supports any emitter property:\n# - Basic: x, y, z (for 3D), photons\n# - Fit results: bg, σ_x, σ_y, σ_z, σ_photons, σ_bg\n# - Metadata: frame, dataset, track_id, id\n\n# Select frames\nframe_5 = filter_frames(smld, 5)                  # Single frame\nearly_frames = filter_frames(smld, 1:10)          # Range of frames (inclusive)\nspecific_frames = filter_frames(smld, [1,3,5,7])  # Specific frames (uses Set for efficiency)\n\n# Select region of interest (ROI) - coordinates in microns\n# 2D ROI\nroi_2d = filter_roi(smld, 1.0:5.0, 2.0:6.0)       # x_range, y_range\n\n# 3D ROI (for 3D emitters only)\nroi_3d = filter_roi(smld, 1.0:5.0, 2.0:6.0, -1.0:1.0)  # x, y, z ranges\n\nSMLD Operations\n\n# Concatenate multiple SMLDs\ncombined = cat_smld(smld1, smld2)\ncombined = cat_smld([smld1, smld2, smld3])\n\n# Merge with options to adjust frame and dataset numbering\nmerged = merge_smld(smld1, smld2)\nmerged = merge_smld([smld1, smld2, smld3])\n\n# Merge with sequential frame numbers\nsequential = merge_smld([smld1, smld2, smld3], adjust_frames=true)\n\n# Merge with sequential dataset numbers\nsequential_ds = merge_smld([smld1, smld2, smld3], adjust_datasets=true)\n\nI/O Operations\n\n# Import from SMITE format (MATLAB)\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")  # Default variable name \"SMD\"\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\", \"CustomSMD\")  # Custom variable name\n\n# Load as 2D or 3D data\nsmld_2d = load_smite_2d(smd)\nsmld_3d = load_smite_3d(smd)\n\n# Export to SMITE format (saved as MATLAB v7.3 format)\n# Note: requires SmiteSMLD object, not BasicSMLD\nsmite_smld = SmiteSMLD(smld.emitters, smld.camera, smld.n_frames, smld.n_datasets, smld.metadata)\nsave_smite(smite_smld, \"output/directory\", \"results.mat\")\n\nNote: The SMITE loader automatically handles complex-valued fields by removing emitters with non-zero imaginary components in key fields (X, Y, Z, Photons, background, and uncertainties). Information about removed emitters is stored in the metadata as \"removed_complex_emitters\" => count.\n\nWorking with SMLD Objects\n\n# Get number of emitters\nn_emitters = length(smld)\n\n# Iterate over emitters\nfor emitter in smld\n    println(\"Emitter at ($(emitter.x), $(emitter.y)) with $(emitter.photons) photons\")\nend\n\n# Display formatted information\nshow(smld)  # Compact view\nshow(stdout, MIME(\"text/plain\"), smld)  # Detailed view\n\nCommon Workflows\n\nCreating and Working with Emitters\n\n# Create emitters\nemitter1 = Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0)\nemitter2 = Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0)\n\n# Create camera\ncam = IdealCamera(512, 512, 0.1)  # 512x512 camera with 0.1 micron pixels\n\n# Create SMLD container\nemitters = [emitter1, emitter2]\nsmld = BasicSMLD(emitters, cam, 1, 1, Dict{String,Any}())\n\nLoading and Filtering Data\n\n# Load from SMITE format\nsmd = SmiteSMD(\"data_directory\", \"localizations.mat\")\nsmld = load_smite_2d(smd)\n\n# Filter by quality\ngood_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02 && photons > 500)\n\n# Filter by ROI\nroi = filter_roi(good_fits, 10.0:20.0, 10.0:20.0)\n\n# Filter by frames\nframes_1_10 = filter_frames(roi, 1:10)\n\nMulti-Dataset Analysis\n\n# Load multiple datasets\nsmd1 = SmiteSMD(\"experiment1\", \"data.mat\")\nsmd2 = SmiteSMD(\"experiment2\", \"data.mat\")\nsmld1 = load_smite_2d(smd1)\nsmld2 = load_smite_2d(smd2)\n\n# Filter each dataset\nbright1 = @filter(smld1, photons > 1000)\nbright2 = @filter(smld2, photons > 1000)\n\n# Merge datasets with sequential frame numbering\nmerged = merge_smld([bright1, bright2], adjust_frames=true)\n\n# Process the merged dataset\nresult = @filter(merged, σ_x < 0.02 && σ_y < 0.02)\n\n# Save the results (convert to SmiteSMLD first if needed)\nresult_smite = SmiteSMLD(result.emitters, result.camera, result.n_frames, result.n_datasets, result.metadata)\nsave_smite(result_smite, \"analysis_results\", \"merged_filtered.mat\")\n\nComplete Example\n\nusing SMLMData\n\n# 1. Create a camera with 100nm pixels\n# Camera has 512x512 pixels, each 0.1 microns (100nm) in size\ncam = IdealCamera(512, 512, 0.1)  # Using convenience constructor  \n\n# 2. Create emitters representing single molecule localizations\nemitters = [\n    # Emitter at (1.0, 2.0) μm with high precision\n    Emitter2DFit{Float64}(1.0, 2.0, 1000.0, 10.0, 0.01, 0.01, 50.0, 2.0),\n    \n    # Bright emitter at (3.0, 4.0) μm\n    Emitter2DFit{Float64}(3.0, 4.0, 1200.0, 12.0, 0.01, 0.01, 60.0, 2.0),\n    \n    # Dimmer emitter at (5.0, 6.0) μm with lower precision\n    Emitter2DFit{Float64}(5.0, 6.0, 800.0, 9.0, 0.03, 0.03, 40.0, 1.5)\n]\n\n# 3. Create SMLD container to hold all data\nsmld = BasicSMLD(\n    emitters,                              # Vector of emitters\n    cam,                                   # Camera geometry\n    1,                                     # Number of frames\n    1,                                     # Number of datasets\n    Dict{String,Any}(\"sample\" => \"Test\")   # Metadata\n)\n\n# 4. Filter by photons to select bright emitters\nbright = @filter(smld, photons > 900)      # Creates new SMLD with filtered emitters\n\n# 5. Select region of interest (ROI)\n# Select emitters in rectangular region: x ∈ [0, 4] μm, y ∈ [1, 5] μm\nroi = filter_roi(bright, 0.0:4.0, 1.0:5.0)\n\n# 6. Examine the results\nprintln(\"Original dataset: $(length(smld)) emitters\")\nprintln(\"After filtering by brightness: $(length(bright)) emitters\")\nprintln(\"After ROI selection: $(length(roi)) emitters\")\n\n# 7. Access individual emitters\nfor (i, emitter) in enumerate(roi)\n    println(\"Emitter $i: position=($(emitter.x), $(emitter.y)) μm, photons=$(emitter.photons)\")\nend\n\n# Output:\n# Original dataset: 3 emitters\n# After filtering by brightness: 2 emitters\n# After ROI selection: 2 emitters\n# Emitter 1: position=(1.0, 2.0) μm, photons=1000.0\n# Emitter 2: position=(3.0, 4.0) μm, photons=1200.0\n\nCommon Pitfalls and Important Notes\n\nCoordinate System\n\nPhysical coordinates are always in microns, not nanometers or pixels\nPixel indices start at 1 (Julia convention), not 0\nFrame numbers start at 1 (default=1, following Julia's 1-based indexing convention)\nThe origin (0,0) in physical space is at the top-left corner of the camera\n\nType Stability\n\nWhen creating emitters, ensure all numeric fields use the same type (e.g., all Float64)\nThe BasicSMLD constructor automatically infers type T from the camera's pixel edges\nMixing types (e.g., Float32 and Float64) can lead to performance issues\n\nFiltering\n\nThe @filter macro creates a new SMLD object; it doesn't modify the original\nFiltering by frames with a vector uses Set internally for O(1) lookup performance\nApplying an ROI filter to incompatible emitter types will throw an error\n\nSMITE Format\n\nComplex-valued fields in SMITE files are automatically handled by removing affected emitters\nThe loader adds metadata about removed emitters: \"removed_complex_emitters\" => count\nSMITE files are saved in MATLAB v7.3 format (HDF5-based)\n\nMemory Considerations\n\nLarge datasets benefit from using appropriate numeric types (e.g., Float32 vs Float64)\nThe filter_frames function with specific frame lists is optimized for sparse selections\nIterating over emitters is memory-efficient (doesn't create intermediate arrays)\n\nCommon Mistakes\n\n# WRONG: Using pixel units instead of microns\nemitter = Emitter2D{Float64}(100, 200, 1000.0)  # ❌ Likely pixel coordinates\n\n# CORRECT: Using micron coordinates\nemitter = Emitter2D{Float64}(10.0, 20.0, 1000.0)  # ✓ Physical coordinates\n\n# WRONG: Modifying original SMLD\nbright = @filter(smld, photons > 1000)\n# smld is unchanged!\n\n# CORRECT: Working with the filtered result\nbright = @filter(smld, photons > 1000)\n# Use 'bright' for further analysis\n\n\n\napi_overview() returns this documentation as a plain String.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.cat_smld-Tuple{Vector{<:AbstractSMLD}}","page":"API Reference","title":"SMLMData.cat_smld","text":"cat_smld(smlds::Vector{<:AbstractSMLD})\ncat_smld(smlds::AbstractSMLD...)\n\nConcatenate multiple SMLD objects into a single SMLD.\n\nArguments\n\nsmlds: Vector of AbstractSMLD objects or multiple AbstractSMLD arguments\n\nReturns\n\nNew AbstractSMLD containing all emitters from inputs\n\nNotes\n\nCamera must be identical across all SMLDs\nn_frames is set to maximum frame number across all inputs\nn_datasets is set to maximum dataset number across all inputs\nMetadata from first SMLD is used, with conflicts noted in metadata\n\nExamples\n\n# Concatenate two SMLDs\ncombined = cat_smld(smld1, smld2)\n\n# Concatenate multiple SMLDs\ncombined = cat_smld(smld1, smld2, smld3)\n\n# Concatenate vector of SMLDs\ncombined = cat_smld([smld1, smld2, smld3])\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.check_complex_fields-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.check_complex_fields","text":"check_complex_fields(s, fields)\n\nCheck if any of the given fields in s are complex and have non-zero imaginary components. Returns a tuple with:\n\nBoolean indicating if any fields are complex with non-zero imaginary parts\nDict mapping field names to arrays of indices with non-zero imaginary parts\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_bin_edges-Tuple{AbstractUnitRange, AbstractUnitRange, Tuple{Real, Real}}","page":"API Reference","title":"SMLMData.compute_bin_edges","text":"compute_bin_edges(centers_x::AbstractUnitRange, centers_y::AbstractUnitRange, pixel_size::Tuple{Real, Real})\n\nCompute pixel edges in both dimensions for rectangular pixels.\n\nArguments\n\ncenters_x::AbstractUnitRange: Range of pixel center indices in x\ncenters_y::AbstractUnitRange: Range of pixel center indices in y\npixel_size::Tuple{Real, Real}: Tuple of (xsize, ysize) in microns\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: (edgesx, edgesy) in physical units (microns)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_bin_edges-Union{Tuple{T}, Tuple{AbstractUnitRange, AbstractUnitRange, T}} where T","page":"API Reference","title":"SMLMData.compute_bin_edges","text":"compute_bin_edges(centers_x::AbstractUnitRange, centers_y::AbstractUnitRange, pixel_size::T) where T\n\nCompute pixel edges in both dimensions. Returns vectors with same type as pixel_size.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.compute_edges_1d-Union{Tuple{T}, Tuple{AbstractUnitRange, T}} where T<:Real","page":"API Reference","title":"SMLMData.compute_edges_1d","text":"compute_edges_1d(centers::AbstractUnitRange, pixel_size::T) where T<:Real\n\nCompute pixel edges in one dimension. Maintains the numeric type of pixelsize. The first edge starts at 0 and each pixel has width pixelsize.\n\nArguments\n\ncenters::AbstractUnitRange: Range of pixel center indices\npixel_size::T: Size of pixels in microns\n\nReturns\n\nVector{T}: Edge positions in physical units (microns), starting at 0\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.filter_frames-Tuple{AbstractSMLD, Integer}","page":"API Reference","title":"SMLMData.filter_frames","text":"filter_frames(smld::AbstractSMLD, frame::Integer)\nfilter_frames(smld::AbstractSMLD, frames::Union{AbstractVector,AbstractRange})\n\nEfficiently select emitters from specified frames.\n\nArguments\n\nsmld::AbstractSMLD: Input SMLD structure\nframes: Single frame number, vector of frame numbers, or range of frames\n\nReturns\n\nNew AbstractSMLD containing only emitters from specified frames\n\nExamples\n\n# Single frame\nframe_5 = filter_frames(smld, 5)\n\n# Range of frames\nearly = filter_frames(smld, 1:10)\n\n# Multiple specific frames\nselected = filter_frames(smld, [1,3,5,7])\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.filter_roi-Tuple{AbstractSMLD, Any, Any}","page":"API Reference","title":"SMLMData.filter_roi","text":"filter_roi(smld::AbstractSMLD, x_range, y_range)\nfilter_roi(smld::AbstractSMLD, x_range, y_range, z_range)\n\nEfficiently select emitters within a region of interest.\n\nArguments\n\nsmld::AbstractSMLD: Input SMLD structure\nx_range: Range or tuple for x coordinates (microns)\ny_range: Range or tuple for y coordinates (microns)\nz_range: Optional range or tuple for z coordinates (microns)\n\nReturns\n\nNew AbstractSMLD containing only emitters within the specified ROI\n\nExamples\n\n# 2D ROI\nregion = filter_roi(smld, 1.0:5.0, 2.0:6.0)\nregion = filter_roi(smld, (1.0, 5.0), (2.0, 6.0))\n\n# 3D ROI\nvolume = filter_roi(smld, 1.0:5.0, 2.0:6.0, -1.0:1.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.format_with_commas-Tuple{Integer}","page":"API Reference","title":"SMLMData.format_with_commas","text":"format_with_commas(n::Integer)\n\nFormat an integer with thousands separators for better readability.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_pixel_centers-Tuple{AbstractCamera}","page":"API Reference","title":"SMLMData.get_pixel_centers","text":"get_pixel_centers(cam::AbstractCamera)\n\nCalculate the physical coordinates of all pixel centers for any camera type.\n\nFor each dimension, the center positions are computed as the midpoint between  consecutive edge positions. This works for both regular (uniform pixel size)  and irregular (varying pixel size) cameras.\n\nArguments\n\ncam::AbstractCamera: Any camera type that implements the AbstractCamera interface with pixeledgesx and pixeledgesy fields in physical units (microns)\n\nReturns\n\nTuple{Vector, Vector}: (centersx, centersy) where each vector contains the physical  coordinates (in microns) of pixel centers along that dimension\n\nExample\n\n# For a 512x512 camera with 0.1 micron pixels\ncam = IdealCamera(1:512, 1:512, 0.1)\ncenters_x, centers_y = get_pixel_centers(cam)\n\n# First pixel center should be at (0.05, 0.05) microns\n@assert centers_x[1] ≈ 0.05\n@assert centers_y[1] ≈ 0.05\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.get_valid_indices-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.get_valid_indices","text":"get_valid_indices(s, complex_indices)\n\nGet indices of elements that don't have complex values with non-zero imaginary parts in any field.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.has_nonzero_imag-Tuple{Any}","page":"API Reference","title":"SMLMData.has_nonzero_imag","text":"has_nonzero_imag(value)\n\nCheck if a value has a non-zero imaginary component. Works for both scalar values and arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.load_smite_2d-Tuple{SmiteSMD}","page":"API Reference","title":"SMLMData.load_smite_2d","text":"load_smite_2d(smd::SmiteSMD)\n\nLoad a 2D Smite SMD .mat file and convert it to SmiteSMLD format. Checks for complex fields and removes emitters with non-zero imaginary components.\n\nArguments\n\nsmd::SmiteSMD: SmiteSMD object specifying the file to load\n\nReturns\n\nSmiteSMLD containing 2D localizations\n\nNotes\n\nAll spatial coordinates are converted to microns\nIf PixelSize is not specified in the file, defaults to 0.1 microns\nEmitters with non-zero imaginary components will be excluded with a warning\nFields are converted from Float32 to Float64 as needed\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.load_smite_3d-Tuple{SmiteSMD}","page":"API Reference","title":"SMLMData.load_smite_3d","text":"load_smite_3d(smd::SmiteSMD)\n\nLoad a 3D Smite SMD .mat file and convert it to SmiteSMLD format. Checks for complex fields and removes emitters with non-zero imaginary components.\n\nArguments\n\nsmd::SmiteSMD: SmiteSMD object specifying the file to load\n\nReturns\n\nSmiteSMLD containing 3D localizations\n\nNotes\n\nAll spatial coordinates are converted to microns\nIf PixelSize is not specified in the file, defaults to 0.1 microns\nEmitters with non-zero imaginary components will be excluded with a warning\nFields are converted from Float32 to Float64 as needed\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.merge_smld-Tuple{Vector{<:AbstractSMLD}}","page":"API Reference","title":"SMLMData.merge_smld","text":"merge_smld(smlds::Vector{<:AbstractSMLD}; adjust_frames=false, adjust_datasets=false)\nmerge_smld(smlds::AbstractSMLD...; adjust_frames=false, adjust_datasets=false)\n\nMerge multiple SMLD objects with options to adjust frame and dataset numbering.\n\nArguments\n\nsmlds: Vector of AbstractSMLD objects or multiple AbstractSMLD arguments\nadjust_frames: If true, adjusts frame numbers to be sequential\nadjust_datasets: If true, adjusts dataset numbers to be sequential\n\nReturns\n\nNew AbstractSMLD containing all emitters with adjusted numbering if requested\n\nNotes\n\nCamera must be identical across all SMLDs\nWhen adjust_frames=true, frame numbers are made sequential across all inputs\nWhen adjust_datasets=true, dataset numbers are made sequential\nMetadata includes information about the merge operation\n\nExamples\n\n# Simple merge\nmerged = merge_smld(smld1, smld2)\n\n# Merge with frame number adjustment\nmerged = merge_smld(smld1, smld2, adjust_frames=true)\n\n# Merge multiple with both adjustments\nmerged = merge_smld([smld1, smld2, smld3], \n                   adjust_frames=true, \n                   adjust_datasets=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.physical_to_pixel-Tuple{Real, Real, Real}","page":"API Reference","title":"SMLMData.physical_to_pixel","text":"physical_to_pixel(x::Real, y::Real, pixel_size::Real)\n\nConvert physical coordinates (in microns) to pixel coordinates.\n\nArguments\n\nx::Real: x coordinate in microns (0,0 is top-left of image)\ny::Real: y coordinate in microns (0,0 is top-left of image)\npixel_size::Real: size of a pixel in microns\n\nReturns\n\nTuple{Float64, Float64}: (px,py) pixel coordinates where (1,1) is center of top-left pixel\n\nExample\n\n# For a camera with 0.1 micron pixels\npx, py = physical_to_pixel(0.05, 0.05, 0.1)  # Point 0.05,0.05 microns from origin\n# Returns (1.0, 1.0) - center of first pixel\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.physical_to_pixel_index-Tuple{Real, Real, Real}","page":"API Reference","title":"SMLMData.physical_to_pixel_index","text":"physical_to_pixel_index(x::Real, y::Real, pixel_size::Real)\n\nConvert physical coordinates (in microns) to integer pixel indices. Returns the pixel that contains the given physical coordinate.\n\nArguments\n\nx::Real: x coordinate in microns (0,0 is top-left of image)\ny::Real: y coordinate in microns (0,0 is top-left of image)\npixel_size::Real: size of a pixel in microns\n\nReturns\n\nTuple{Int, Int}: (px,py) pixel indices where (1,1) is top-left pixel\n\nExample\n\n# For a camera with 0.1 micron pixels\npx, py = physical_to_pixel_index(0.05, 0.05, 0.1)  # Point at center of first pixel\n# Returns (1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.pixel_to_physical-Union{Tuple{T}, Tuple{Real, Real, T}} where T","page":"API Reference","title":"SMLMData.pixel_to_physical","text":"pixel_to_physical(px::Real, py::Real, pixel_size::T) where T\n\nConvert pixel coordinates to physical coordinates (in microns). Returns coordinates with the same type as pixel_size.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.save_smite-Tuple{SmiteSMLD, String, String}","page":"API Reference","title":"SMLMData.save_smite","text":"save_smite(smld::SmiteSMLD, filepath::String, filename::String)\n\nSave SmiteSMLD data back to SMITE's SMD .mat format.\n\nArguments\n\nsmld::SmiteSMLD: SMLD object to save\nfilepath::String: Directory path where to save the file\nfilename::String: Name of the output .mat file\n\nNotes\n\nSaves in MATLAB v7.3 format\nPreserves all metadata fields\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMData.@filter-Tuple{Any, Any}","page":"API Reference","title":"SMLMData.@filter","text":"@filter(smld, condition)\n\nFilter SMLD emitters using a natural condition syntax. Transforms expressions at compile time into efficient filtering operations.\n\nExamples\n\n# Simple conditions\nbright = @filter(smld, photons > 1000)\nearly = @filter(smld, frame < 10)\n\n# Compound conditions\ngood_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02)\nroi = @filter(smld, 1.0 <= x <= 5.0 && 1.0 <= y <= 5.0)\n\n\n\n\n\n","category":"macro"},{"location":"#SMLMData.jl","page":"Home","title":"SMLMData.jl","text":"Data types and utilities for Single Molecule Localization Microscopy (SMLM) in Julia.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"SMLMData.jl provides core data structures and operations for working with Single Molecule Localization Microscopy data. The package follows a type-based design that makes it easy to represent, manipulate, and analyze localization data.","category":"section"},{"location":"#Ecosystem-Role","page":"Home","title":"Ecosystem Role","text":"SMLMData is the core types package for the JuliaSMLM ecosystem. It defines the foundational types (emitters, cameras, SMLD containers) that all other packages share.\n\nYou rarely need to import SMLMData directly. Packages like GaussMLE, SMLMBoxer, and SMLMAnalysis depend on SMLMData and re-export the types you need:\n\nusing GaussMLE      # Re-exports ROIBatch, camera types, etc.\nusing SMLMAnalysis  # Re-exports all SMLMData types for analysis workflows\n\nDirect using SMLMData is primarily for package developers, standalone data manipulation, or learning the type system.","category":"section"},{"location":"#Emitters","page":"Home","title":"Emitters","text":"Emitters represent individual fluorophore localizations in single molecule localization microscopy. SMLMData provides several emitter types to accommodate different analysis needs.","category":"section"},{"location":"#Emitter-Type-Hierarchy","page":"Home","title":"Emitter Type Hierarchy","text":"All emitter types derive from the abstract AbstractEmitter base type:\n\nAbstractEmitter\n ├─ Emitter2D{T}      - Basic 2D emitter with position and photons\n ├─ Emitter3D{T}      - Basic 3D emitter with position and photons\n ├─ Emitter2DFit{T}   - 2D emitter with fit results and uncertainties\n └─ Emitter3DFit{T}   - 3D emitter with fit results and uncertainties","category":"section"},{"location":"#Basic-Emitter-Types","page":"Home","title":"Basic Emitter Types","text":"The most basic emitter types store only position and photon count:\n\nstruct Emitter2D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\nstruct Emitter3D{T} <: AbstractEmitter\n    x::T           # x-coordinate in microns\n    y::T           # y-coordinate in microns\n    z::T           # z-coordinate in microns\n    photons::T     # number of photons emitted\nend\n\nThese types are useful for:\n\nSimulating fluorophore emissions\nRepresenting ground truth data\nSimple visualization scenarios","category":"section"},{"location":"#Fit-Result-Emitter-Types","page":"Home","title":"Fit Result Emitter Types","text":"For real data analysis, SMLMData provides extended emitter types that include fit results with uncertainties and tracking information:\n\nmutable struct Emitter2DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_xy::T        # covariance between x and y (microns², 0 = axis-aligned)\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\nmutable struct Emitter3DFit{T} <: AbstractEmitter\n    x::T           # fitted x-coordinate in microns\n    y::T           # fitted y-coordinate in microns\n    z::T           # fitted z-coordinate in microns\n    photons::T     # fitted number of photons\n    bg::T          # fitted background in photons/pixel\n    σ_x::T         # uncertainty in x position in microns\n    σ_y::T         # uncertainty in y position in microns\n    σ_z::T         # uncertainty in z position in microns\n    σ_xy::T        # covariance between x and y (microns², 0 = uncorrelated)\n    σ_xz::T        # covariance between x and z (microns², 0 = uncorrelated)\n    σ_yz::T        # covariance between y and z (microns², 0 = uncorrelated)\n    σ_photons::T   # uncertainty in photon count\n    σ_bg::T        # uncertainty in background level\n    frame::Int     # frame number in acquisition sequence\n    dataset::Int   # identifier for specific acquisition/dataset\n    track_id::Int  # identifier for linking localizations across frames\n    id::Int        # unique identifier within dataset\nend\n\nThese types are suitable for:\n\nStoring localization analysis results\nQuality control and filtering\nTracking and trajectory analysis\nMulti-dataset analysis","category":"section"},{"location":"#Creating-Emitters","page":"Home","title":"Creating Emitters","text":"# Basic 2D emitter\nemitter_2d = Emitter2D{Float64}(1.5, 2.3, 1000.0)  # x, y, photons\n\n# Basic 3D emitter\nemitter_3d = Emitter3D{Float64}(1.5, 2.3, -0.5, 1000.0)  # x, y, z, photons\n\n# 2D emitter with fit results using convenience constructor\nemitter_2d_fit = Emitter2DFit{Float64}(\n    1.5, 2.3,        # x, y coordinates (μm)\n    1000.0, 10.0,    # photons, background\n    0.01, 0.01,      # σ_x, σ_y (uncertainties in μm)\n    50.0, 2.0;       # σ_photons, σ_bg (uncertainties)\n    σ_xy=0.005,      # covariance (optional, 0 = axis-aligned)\n    frame=5,         # frame number\n    dataset=1,       # dataset identifier\n    track_id=2,      # tracking identifier (0 = unlinked)\n    id=42            # unique identifier\n)\n\n# 3D emitter with fit results\nemitter_3d_fit = Emitter3DFit{Float64}(\n    1.5, 2.3, -0.5,    # x, y, z coordinates (μm)\n    1000.0, 10.0,      # photons, background\n    0.01, 0.01, 0.02,  # σ_x, σ_y, σ_z (uncertainties in μm)\n    50.0, 2.0;         # σ_photons, σ_bg (uncertainties)\n    σ_xy=0.005, σ_xz=0.002, σ_yz=0.003,  # covariances (optional, 0 = uncorrelated)\n    frame=5,           # frame number\n    dataset=1,         # dataset identifier\n    track_id=2,        # tracking identifier (0 = unlinked)\n    id=42              # unique identifier\n)","category":"section"},{"location":"#Type-Parameter","page":"Home","title":"Type Parameter","text":"All emitter types use a type parameter T to specify the numeric precision:\n\n# Float64 precision (default)\nemitter_f64 = Emitter2D{Float64}(1.0, 2.0, 1000.0)\n\n# Float32 precision for reduced memory usage\nemitter_f32 = Emitter2D{Float32}(1.0f0, 2.0f0, 1000.0f0)","category":"section"},{"location":"#Cameras","page":"Home","title":"Cameras","text":"Cameras define the imaging system's geometry and handling of pixel coordinates.","category":"section"},{"location":"#Camera-Types","page":"Home","title":"Camera Types","text":"SMLMData provides two camera types:\n\nIdealCamera: For detectors with Poisson noise only (e.g., EMCCD in photon-counting mode)\nSCMOSCamera: For sCMOS detectors with pixel-dependent calibration parameters","category":"section"},{"location":"#IdealCamera","page":"Home","title":"IdealCamera","text":"# Create a camera with 512x512 pixels, each 100nm (0.1μm) in size\ncamera = IdealCamera(512, 512, 0.1)\n\n# For non-square pixels, specify different x and y sizes\ncamera_rect = IdealCamera(512, 512, (0.1, 0.12))","category":"section"},{"location":"#SCMOSCamera","page":"Home","title":"SCMOSCamera","text":"# Minimal: uniform readnoise (assumes offset=0, gain=1, qe=1)\ncam_scmos = SCMOSCamera(512, 512, 0.1, 1.6)  # 1.6 e⁻ rms readnoise\n\n# From camera spec sheet (e.g., ORCA-Flash4.0 V3)\ncam_flash = SCMOSCamera(\n    2048, 2048, 0.065,  # 2048×2048 pixels, 65nm pixel size\n    1.6,                 # 1.6 e⁻ rms readnoise from spec\n    offset = 100.0,      # typical dark level (ADU)\n    gain = 0.46,         # 0.46 e⁻/ADU from spec\n    qe = 0.72            # 72% QE at 550nm\n)\n\n# With per-pixel calibration maps (precision SMLM)\nreadnoise_map = load(\"camera_noise.mat\")  # 512×512 measured values\ngain_map = load(\"camera_gain.mat\")\nqe_map = load(\"camera_qe.mat\")\ncam_calibrated = SCMOSCamera(512, 512, 0.1, readnoise_map,\n                              gain=gain_map, qe=qe_map)\n\n# Mixed scalar and matrix parameters\ncam_mixed = SCMOSCamera(\n    512, 512, 0.1, readnoise_map,  # Per-pixel noise\n    offset = 100.0,                 # Uniform offset\n    gain = 0.5                      # Uniform gain\n)\n\nSCMOSCamera Parameters:\n\noffset: Dark level in ADU (analog-to-digital units)\ngain: Conversion gain in e⁻/ADU (electrons per ADU)\nreadnoise: Read noise in e⁻ rms (root-mean-square, matches spec sheets)\nqe: Quantum efficiency (dimensionless, 0-1)\n\nEach parameter can be:\n\nScalar: Uniform value across the sensor\nMatrix: Per-pixel calibration map (size must match pixel grid)","category":"section"},{"location":"#Coordinate-Conventions","page":"Home","title":"Coordinate Conventions","text":"All spatial coordinates are in microns\nPhysical space: (0,0) at top-left corner of camera\nPixel space: (1,1) at center of top-left pixel\n\n# Convert between coordinate systems\nx_physical, y_physical = pixel_to_physical(10.5, 15.5, 0.1)\npx, py = physical_to_pixel(1.05, 1.55, 0.1)","category":"section"},{"location":"#ROI-Batch-Types","page":"Home","title":"ROI Batch Types","text":"ROI (Region of Interest) batch types provide efficient storage and processing of image regions extracted from SMLM data. These types enable batched processing workflows across the JuliaSMLM ecosystem.","category":"section"},{"location":"#SingleROI","page":"Home","title":"SingleROI","text":"A single region of interest with its location context:\n\nstruct SingleROI{T}\n    data::Matrix{T}              # ROI image data (roi_size × roi_size)\n    corner::SVector{2,Int32}     # (x, y) = (col, row) corner position\n    frame_idx::Int32             # Frame number (1-indexed)\nend\n\n# Example\nroi_data = rand(Float32, 11, 11)\nroi = SingleROI(roi_data, SVector{2,Int32}(100, 200), Int32(5))","category":"section"},{"location":"#ROIBatch","page":"Home","title":"ROIBatch","text":"A batch of ROIs for efficient parallel processing:\n\nstruct ROIBatch{T,N,A<:AbstractArray{T,N},C<:AbstractCamera}\n    data::A                      # ROI stack (roi_size × roi_size × n_rois)\n    x_corners::Vector{Int32}     # X (column) coordinates of ROI corners\n    y_corners::Vector{Int32}     # Y (row) coordinates of ROI corners\n    frame_indices::Vector{Int32} # Frame number for each ROI\n    camera::C                    # Camera object\n    roi_size::Int                # Size of each ROI (square)\nend","category":"section"},{"location":"#Creating-ROI-Batches","page":"Home","title":"Creating ROI Batches","text":"# From arrays\ncamera = IdealCamera(512, 512, 0.1)\ndata = rand(Float32, 11, 11, 100)  # 100 ROIs of 11×11 pixels\ncorners = rand(Int32(1):Int32(500), 2, 100)\nframes = rand(Int32(1):Int32(50), 100)\nbatch = ROIBatch(data, corners, frames, camera)\n\n# From separate x/y corner vectors\nx_corners = rand(Int32(1):Int32(500), 100)\ny_corners = rand(Int32(1):Int32(500), 100)\nbatch = ROIBatch(data, x_corners, y_corners, frames, camera)\n\n# From vector of SingleROI\nusing StaticArrays\nrois = [SingleROI(rand(Float32, 11, 11), SVector{2,Int32}(i*10, i*10), Int32(i))\n        for i in 1:100]\nbatch = ROIBatch(rois, camera)","category":"section"},{"location":"#Working-with-ROI-Batches","page":"Home","title":"Working with ROI Batches","text":"# Indexing\nroi = batch[5]  # Returns SingleROI\n\n# Iteration\nfor roi in batch\n    # Process each ROI\n    process(roi.data, roi.corner, roi.frame_idx)\nend\n\n# Length\nn_rois = length(batch)\n\n# GPU adaptation\nusing CUDA\nbatch_gpu = adapt(CuArray, batch)  # Transfer to GPU","category":"section"},{"location":"#Coordinate-System","page":"Home","title":"Coordinate System","text":"Camera coordinates: 1-indexed, (1,1) = top-left of full image\nROI corners: (x, y) = (col, row) position in camera coordinates\nROI data: Local coordinates, (1,1) = top-left within ROI\nFrame indices: 1-indexed","category":"section"},{"location":"#Typical-Workflow","page":"Home","title":"Typical Workflow","text":"Extract ROIs: Use SMLMBoxer.jl to detect and extract ROIs from image stack\nFit ROIs: Use GaussMLE.jl to fit Gaussian PSFs to each ROI\nConvert to SMLD: Convert fit results to BasicSMLD for further analysis","category":"section"},{"location":"#SMLD","page":"Home","title":"SMLD","text":"SMLD (Single Molecule Localization Data) is the container type that holds emitters and camera information.","category":"section"},{"location":"#Creating-an-SMLD","page":"Home","title":"Creating an SMLD","text":"# Create a vector of emitters\nemitters = [\n    Emitter2D{Float64}(1.0, 2.0, 1000.0),\n    Emitter2D{Float64}(3.0, 4.0, 1200.0)\n]\n\n# Create a BasicSMLD\nsmld = BasicSMLD(emitters, camera, 1, 1, Dict{String,Any}())\n\n# Add metadata\nsmld_with_metadata = BasicSMLD(\n    emitters, \n    camera, \n    10,  # number of frames\n    1,   # number of datasets\n    Dict{String,Any}(\n        \"exposure_time\" => 0.1,\n        \"sample\" => \"Test Sample\"\n    )\n)","category":"section"},{"location":"#Filtering-Operations","page":"Home","title":"Filtering Operations","text":"# Filter by emitter properties\nbright_emitters = @filter(smld, photons > 1000)\nprecise_fits = @filter(smld, σ_x < 0.02 && σ_y < 0.02)\n\n# Select region of interest\nregion = filter_roi(smld, 0.0:2.0, 1.0:3.0)\n\n# Select frames\nframe_5 = filter_frames(smld, 5)\nearly_frames = filter_frames(smld, 1:10)","category":"section"},{"location":"#Combining-SMLDs","page":"Home","title":"Combining SMLDs","text":"# Concatenate two SMLD objects\ncombined = cat_smld(smld1, smld2)\n\n# Merge with sequential frame numbering\nmerged = merge_smld([smld1, smld2], adjust_frames=true)","category":"section"},{"location":"#File-I/O","page":"Home","title":"File I/O","text":"SMLMData currently supports the SMITE format, with more formats planned for future releases.\n\n# Import from SMITE format (MATLAB)\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\nsmld_2d = load_smite_2d(smd)\nsmld_3d = load_smite_3d(smd)\n\n# Export to SMITE format\nsave_smite(smld, \"output/directory\", \"results.mat\")","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SMLMData\")\n\nFor complete API documentation, see the API Reference.","category":"section"},{"location":"io/#File-I/O","page":"Saving and Loading","title":"File I/O","text":"SMLMData provides functionality for importing and exporting localization data in various formats. This page documents the currently supported formats and related functions.","category":"section"},{"location":"io/#SMITE-Format","page":"Saving and Loading","title":"SMITE Format","text":"SMITE is a MATLAB-based format commonly used in single molecule localization microscopy. SMLMData provides types and functions for interfacing with this format.","category":"section"},{"location":"io/#Types","page":"Saving and Loading","title":"Types","text":"# Helper type for loading SMITE .mat files\nstruct SmiteSMD \n    filepath::String    # Path to the directory containing the .mat file\n    filename::String    # Name of the .mat file\n    varname::String     # Variable name in the .mat file (default: \"SMD\")\nend\n\n# Constructor with default variable name\nSmiteSMD(filepath::String, filename::String) = SmiteSMD(filepath, filename, \"SMD\")\n\n# SMLD type compatible with SMITE format\nstruct SmiteSMLD{T,E<:AbstractEmitter} <: AbstractSMLD\n    emitters::Vector{E}\n    camera::AbstractCamera\n    n_frames::Int\n    n_datasets::Int\n    metadata::Dict{String,Any}\nend","category":"section"},{"location":"io/#Loading-SMITE-Data","page":"Saving and Loading","title":"Loading SMITE Data","text":"SMLMData provides separate functions for loading 2D and 3D data from SMITE format:\n\n# Load 2D data\nsmd = SmiteSMD(\"path/to/data\", \"localizations.mat\")\nsmld_2d = load_smite_2d(smd)\n\n# Load 3D data\nsmld_3d = load_smite_3d(smd)\n\nBoth functions handle:\n\nConversion of coordinates to microns\nCreation of appropriate camera model\nPreservation of metadata\n\nExample:\n\n# Load SMITE data\nsmd = SmiteSMD(\"/data/microscopy\", \"cell1_localizations.mat\")\nsmld = load_smite_2d(smd)\n\n# Inspect metadata\nprintln(\"Loaded $(length(smld.emitters)) emitters\")\nprintln(\"Image size: $(smld.metadata[\"data_size\"])\")\nprintln(\"Pixel size: $(smld.metadata[\"pixel_size\"]) μm\")","category":"section"},{"location":"io/#Saving-SMITE-Data","page":"Saving and Loading","title":"Saving SMITE Data","text":"You can save any SMLD object back to SMITE format:\n\n# Save to SMITE format\nsave_smite(smld, \"output/directory\", \"processed_results.mat\")\n\nThe save_smite function:\n\nConverts SMLMData structures to SMITE's structure\nPreserves all metadata fields\nSaves in MATLAB v7.3 format\n\nExample workflow:\n\n# Load data\nsmd = SmiteSMD(\"raw_data\", \"experiment1.mat\")\nsmld = load_smite_2d(smd)\n\n# Process data\nbright = @filter(smld, photons > 1000)\nroi = filter_roi(bright, 10.0:20.0, 10.0:20.0)\n\n# Add analysis info to metadata\nroi.metadata[\"analysis_date\"] = Dates.now()\nroi.metadata[\"selection_criteria\"] = \"photons > 1000, ROI (10-20,10-20)\"\n\n# Save processed data\nsave_smite(roi, \"processed_data\", \"experiment1_processed.mat\")","category":"section"},{"location":"io/#Future-File-Formats","page":"Saving and Loading","title":"Future File Formats","text":"SMLMData is designed to be extended with additional file formats. Future versions may include support for:\n\nCSV formats\nHDF5\nThunderSTORM\nPicasso\n\nWhen new formats are added, they will be documented in this section.","category":"section"}]
}
